Pengenalan Laravel
Laravel adalah framework di PHP untuk membuat Web atau API
Laravel pertama kali dibuat oleh Taylor Otwell tahun 2011
Laravel adalah framework yang open source dan gratis, sehingga kita bisa menggunakannya tanpa biaya dan juga bisa berkontribusi ke projectnya
https://laravel.com/
https://github.com/laravel/laravel

Kenapa Laravel?
Saat ini Laravel adalah framework paling populer di PHP
Banyak perusahaan yang sudah menggunakan Laravel sebagai framework pilihan ketika menggunakan PHP
Laravel juga memiliki ekosistem yang sangat besar, terutama dari ekosistem teknologi pendukung, sehingga ketika menggunakan Laravel, kita bisa mengintegrasikan dengan teknologi pendukung nya dengan lebih mudah

Model View Controller
Laravel sendiri membawa konsep MVC (Model View Controller)
Sehingga jika kita sudah terbiasa dengan konsep tersebut, kita akan dengan mudah menggunakan Laravel
Detail dari konsep MVC itu sendiri sudah dibahas di kelas PHP MVC

Versi Laravel
https://laravel.com/docs/master/releases

Library
Laravel sendiri sebenarnya tidak membuat semua bagian pada framework nya sendiri
Beberapa bagian menggunakan library yang sudah populer di PHP, dan sudah kita bahas di roadmap kelas PHP
Contohnya untuk project management, Laravel menggunakan Composer
Untuk Logging, Laravel menggunakan Monolog
Untuk Unit Test, Laravel menggunakan PHPUnit
Dan lain-lain

Server Requirements
PHP >= 8.0
BCMath PHP Extension
Ctype PHP Extension
cURL PHP Extension
DOM PHP Extension
Fileinfo PHP Extension
JSON PHP Extension
Mbstring PHP Extension
OpenSSL PHP Extension
PCRE PHP Extension
PDO PHP Extension
Tokenizer PHP Extension
XML PHP Extension

Membuat Project
Laravel menggunakan Composer untuk project management nya
Dan untuk membuat projectnya pun kita bisa menggunakan Composer dengan perintah :
composer create-project laravel/laravel=version nama-folder
https://packagist.org/packages/laravel/laravel

Struktur Project

Menjalankan Laravel

Artisan
Saat kita membuat project Laravel, laravel sendiri sudah menyediakan secara otomatis sebuah file bernama artisan
File artisan ini sendiri sebenarnya adalah file yang berisi kode php
Kita bisa menggunakan perintah “php artisan” untuk melihat semua feature yang bisa dilakukan oleh file artisan

Menjalankan Laravel
File artisan bisa digunakan untuk melakukan banyak hal, salah satunya menjalankan aplikasi laravel ketika proses development
Untuk menjalankan aplikasi laravel dalam mode development, kita bisa gunakan perintah :
php artisan serve

Git
Saat kita membuat project Laravel, kita direkomendasikan untuk menggunakan Git sebagai source code management nya
Kita juga bisa melihat ada file seperti .gitignore yang otomatis dibuat di project Laravel, untuk memberi tahu, bagian mana yang tidak perlu di commit ke dalam Git repository
Jika teman-teman belum terbiasa dengan Git, saya sarankan mengikuti kelas Git saya sudah saya buat
https://kelas.programmerzamannow.com/p/git-untuk-pemula-sampai-mahir

Artisan
Saat membuat project Laravel, Laravel menyediakan sebuah file bernama artisan
File artisan ini adalah kode PHP yang bisa digunakan untuk banyak hal, kita akan bahas fitur-fitur file artisan ini secara bertahap di materi-materi selanjutnya

Melihat Semua Fitur File Artisan
Untuk melihat semua fitur file artisan, kita bisa gunakan perintah :
php artisan
Secara otomatis kita bisa lihat semua fitur yang terdapat di file artisan

Melihat Detail Informasi
Untuk melihat detail informasi perintah yang terdapat di file artisan, kita bisa gunakan perintah :
php artisan perintah --help
Contoh :
php artisan serve --help

Request Lifecycle
Sebelum kita membuat kode program menggunakan Laravel, ada baiknya kita perlu tahu cara kerja Laravel itu sendiri
Terutama bagaimana alur hidup dari request yang kita lakukan ke aplikasi Laravel
Jika teman-teman sudah mengikuti kelas PHP MVC yang saya buat, harusnya tidak akan terlalu bingung, karena hampir sama cara kerja nya

public/index.php
Entry point pertama dari aplikasi Laravel adalah sebuah file index.php yang terdapat di folder public
Semua request yang masuk ke aplikasi Laravel, maka akan masuk melalui file ini
File ini sengaja disimpan di dalam folder public tersendiri, agar file-file kode program lainnya tidak bisa diakses via URL
Ini file index.php sebenarnya tidak ada yang kompleks, hanya me-load framework Laravel, dan menjalankan kode program yang kita buat

Kernel
Dari index.php, request akan dilanjutkan ke class Kernel
Di Laravel, terdapat dua jenis Kernel, HTTP Kernel, dan Console Kernel. HTTP Kernel digunakan untuk menangani request berupa HTTP, sedangkan Console Kernel digunakan untuk menangani request berupa perintah console
Pada kelas ini kita bahas tentang HTTP Kernel, jadi ketika request web masuk ke index.php, maka request akan dilanjutkan ke HTTP Kernel

Service Provider
Kernel sendiri sebenarnya adalah core dari logic aplikasi, dimana di dalam Kernel, request yang masuk di tangani sampai mendapatkan response
Kernel melakukan beberapa hal, pertama Kernel melakukan proses bootstraping, yaitu me-load yang namanya Service Provider, yang akan kita bahas di materi terpisah
Laravel akan melakukan iterasi semua Service Provider dan melakukan proses registrasi dan juga bootstraping untuk semua Service Provider
Service Provider ini lah yang bertanggung jawab melakukan bootstraping semua komponen di Laravel, seperti database, queue, validation, routing dan lain-lain

Testing
Laravel menggunakan PHPUnit untuk implementasi unit test nya
Secara garis besar, di Laravel terdapat dua jenis test, unit test dan feature test / integration test

Unit Test
Untuk unit test, kita bisa membuat class unit test seperti menggunakan PHP Unit biasanya
Yaitu dengan membuat class turunan dari PHPUnit\Framework\TestCase
Jika kita perlu membuat test tanpa harus menggunakan fitur Laravel, maka kita cukup buat Unit Test saja

Integration Test
Laravel memiliki fitur yang mempermudah kita ketika membuat integration test
Bedanya dari unit test, di integration test, aplikasi laravel bisa diakses dengan mudah, misal kita nanti mau memanggil Database, Controller, dan lain-lain
Untuk membuat Integration Test, kita cukup membuat class turunan dari Illuminate\Foundation\Testing\TestCase
Integration Test akan lebih lambat dibandingkan Unit Test, karena kita butuh me-load framework Laravel terlebih dahulu
Dan jika kita membutuhkan fitur Laravel, maka kita wajib menggunakan Integration Test

Membuat Test
Untuk membuat Integration Test, kita bisa lakukan manual, atau kita bisa gunakan file artisan menggunakan perintah :
php artisan make:test NamaTest
Secara otomatis akan masuk ke folder tests/Feature
Jika kita ingin membuat Unit Test, kita bisa gunakan perintah :
php artisan make:test NamaTest --unit
Secara otomatis akan masuk ke folder tests/Unit

Menjalankan Test
Untuk menjalankan test, kita bisa gunakan PHPUnit seperti biasanya
Atau jika ingin menjalankan semua test, bisa menggunakan file artisan dengan perintah :
php artisan test

Environment
Saat kita membuat aplikasi, kadang kita perlu menyimpan nilai konfigurasi di environment variable
Laravel memiliki fitur untuk memudahkan kita mengambil data dari environment variable
Kita bisa menggunakan function env(key) atau Env::get(key) untuk mendapatkan nilai dari environment variable
Internal implementasi dari Environment variable di Laravel menggunakan library https://github.com/vlucas/phpdotenv

Kode : Environment Variable
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Env;
use Tests\TestCase;

class EnvironmentTest extends TestCase
{
    public function testGetEnv()
    {
        $youtube = env('YOUTUBE');

        self::assertEquals('Programmer Zaman Now', $youtube);
    }

    public function testDefaultEnv()
    {
        $author = Env::get('AUTHOR', 'Eko');

        self::assertEquals('Eko', $author);
    }


}

Kode : Test Environment Variable

File .env
Selain membaca dari environment variable, Laravel juga memiliki kemampuan untuk membaca nilai dari file .env yang terdapat di project Laravel
Ini lebih mudah dibandingkan mengubah environment variable di sistem operasi
Kita cukup menambah environment variable ke file .env
File .env secara default di ignore di Git project Laravel, oleh karena itu, kita bisa menambahkan konfigurasi di local tanpa takut ter-commit ke Git Repository

Kode : File .env
YOUTUBE='Programmer Zaman Now'

APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:8yKx5XZ8KxlLe1ZyOv6OcVLHKXA1AtRpq8RHi86d2f0=
APP_DEBUG=true
APP_URL=http://localhost

Default Value
Laravel mendukung default value untuk environment variable
Default value adalah nilai yang akan digunakan ketika environment variable yang kita ambil tidak tersedia
Kita bisa menggunakan function env(key, default) atau Env::get(key, default)

Kode : Default Environment Value
    public function testDefaultEnv()
    {
        $author = Env::get('AUTHOR', 'Eko');

        self::assertEquals('Eko', $author);
    }

Application Environment
Saat membuat aplikasi, kadang kita ingin menentukan saat ini sedang berjalan di environment mana, misal di local, di dev, di staging, di qa atau di production
Di Laravel, hal ini biasanya dilakukan dengan menggunakan environment variable APP_ENV
Dan untuk mengecek saat ini sedang berjalan di environment apa, kita bisa menggunakan function App::environment(value) atau App::environment([value1, value2]), dimana akan return true jika benar

Kode : PHP Unit
        <env name="APP_ENV" value="testing"/>
        <env name="BCRYPT_ROUNDS" value="4"/>
        <env name="CACHE_DRIVER" value="array"/>

Kode : Application Environment
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\App;
use Tests\TestCase;

class AppEnvironmentTest extends TestCase
{
    public function testAppEnv() {
        if(App::environment(['testing', 'prod', 'dev'])){
            // kode program kita
            self::assertTrue(true);
        }
    }
}

Configuration
Environment variable cocok digunakan untuk jenis konfigurasi yang memang butuh berubah-ubah nilainya, dan terintegrasi dengan baik dengan environment variable di sistem operasi
Laravel juga mendukung penulisan konfigurasi dengan menggunakan PHP Code, konfigurasi ini biasanya digunakan ketika memang dibutuhkan tidak terlalu sering berubah, dan biasanya pengaturannya hampir sama untuk tiap lokasi dijalankan aplikasi
Namun saat menggunakan fitur Laravel Configuration, kita juga tetap bisa mengakses Environment Variable

Folder Configuration
Laravel menyimpan semua konfigurasi di folder config yang terdapat di project
Dan prefix dari konfigurasi diawali dengan file php yang terdapat di project tersebut

Membuat File Konfigurasi
Untuk membuat file konfigurasi, kita cukup membuat file php di dalam folder config
Lalu di dalam file tersebut, kita cukup return konfigurasi dalam bentuk array

Kode : contoh.php
<?php

return [
    "author" => [
        "first" => "adi",
        "last" => "putra"
    ],
    "email" => "adi@gmail.com",
    "web" => "hoho.com"
];

Mengambil Konfigurasi
Untuk mengambil konfigurasi di file konfigurasi, kita bisa menggunakan function config(key, default)
Dimana pembuatan key pada config diawali dengan nama file, lalu diikuti dengan key yang terdapat di dalam return value nya
Tiap nested array menggunakan . (titik)
Misal contoh.author.first, artinya kita ambil konfigurasi dari file contoh.php, lalu ambil data array key author, dan di dalamnya kita ambil data key first
Sama seperti function env(), function config() juga memiliki parameter default value jika key konfigurasinya tidak tersedia

Kode : Config Test
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ConfigurationTest extends TestCase
{
    public function testConfig()
    {
        $firstName = config("contoh.author.first");
        $lastName = config("contoh.author.last");
        $email = config("contoh.email");
        $web = config("contoh.web");

        self::assertEquals("adi", $firstName);
        self::assertEquals("putra", $lastName);
        self::assertEquals("adi@gmail.com", $email);
        self::assertEquals("hoho.com", $web);
    }
}

Configuration Cache
Saat kita membuat terlalu banyak file konfigurasi, lama-lama maka akan membuat proses baca konfigurasi menjadi lambat karena Laravel harus membaca file setiap kali kita mengambil konfigurasi
Pada saat proses development, hal ini mungkin bukan masalah, namun jika sudah masuk ke production, maka ini bisa memperlambat performa aplikasi Laravel kita
Laravel memiliki fitur untuk meng-cache data konfigurasi yang kita buat menjadi satu file sehingga proses membacanya lebih cepat karena datanya langsung di load saat aplikasi berjalan
Untuk membuat configuration cache, kita bisa gunakan perintah :
php artisan config:cache

Lokasi Configuration Cache

Hapus Configuration Cache
Ketika file cache sudah dibuat, jika kita menambah konfigurasi di file php yang terdapat di folder config, maka config tersebut tidak akan bisa diakses
Hal ini karena Laravel akan selalu menggunakan configuration cache jika ada, oleh karena itu kita bisa buat ulang cache nya, atau jika ingin menghapus cache nya, kita bisa gunakan perintah :
php artisan config:clear

Dependency Injection
Di dalam pengembangan perangkat lunak, ada konsep yang namanya Dependency Injection
Dependency Injection adalah teknik dimana sebuah object menerima object lain yang dibutuhka atau istilahnya dependencies
Saat kita membuat object, sering sekali kita membuat object yang butuh object lain
https://en.wikipedia.org/wiki/Dependency_injection

Kode : Foo Class
<?php

namespace App\Data;

class Foo
{
    public function foo(): string
    {
        return "Foo";
    }
}

Kode : Bar Class
<?php

namespace App\Data;

class Bar
{
    public Foo $foo;

    public function __construct(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function bar(): string
    {
        return $this->foo->foo() . ' and Bar';
    }
}

Foo dan Bar
Dari class Foo dan Bar kita tahu bahwa Bar membutuhkan Foo, artinya Bar depends-on Foo, atau Foo adalah dependency untuk Bar
Dependency Injection berarti kita perlu memasukkan object Foo ke dalam Bar, sehingga Bar bisa menggunakan object Foo
Pada kode Foo dan Bar kita menggunakan Constructor untuk melakukan injection (memasukkan dependency), sebenarnya caranya tidak hanya menggunakan Constructor, bisa menggunakan Attribute atau Function, namun sangat direkomendasikan menggunakan Constructor agar bisa terlihat jelas dependencies nya dan kita tidak lupa menambahkan dependencies nya

Kode : Dependency Injection
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class DependencyInjectionTest extends TestCase
{
    public function testDependencyInjection()
    {
        $foo = new Foo();
        $bar = new Bar($foo);
        //        $bar->setFoo($foo);
        //        $bar->foo = $foo;

        self::assertEquals('Foo and Bar', $bar->bar());
    }
}

Service Container
Sebelumnya kita sudah mencoba melakukan Dependency Injection secara manual
Laravel memiliki fitur Dependency Injection secara otomatis, dan ini wajib dikuasai agar lebih mudah membuat aplikasi menggunakan Laravel
Di Laravel fitur ini bernama Service Container, dimana Service Container ini merupakan fitur yang digunakan untuk manajemen dependencies dan juga dependency injection

Application Class
Service Container di Laravel direpresentasikan dalam class bernama Application
Kita tidak perlu membuat class Application secara manual, karena semua sudah dilakukan secara otomatis oleh framework Laravel
Di semua project Laravel, hampir disemua bagian terdapat field $app yang merupakan instance dari Application
https://laravel.com/api/9.x/Illuminate/Foundation/Application.html

Membuat Dependency
Dengan menggunakan Service Container, kita tidak perlu membuat object secara manual lagi menggunakan kata kunci new
Kita bisa menggunakan function make(key) yang terdapat di class Application untuk membuat dependency secara otomatis
Saat kita menggunakan make(key), object akan selalu dibuat baru, jadi harap hati-hati ketika menggunakannya, karena dia bukan menggunakan object yang sama

Kode : Membuat Dependency
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use App\Data\Person;
use App\Services\HelloService;
use App\Services\HelloServiceIndonesia;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ServiceContainerTest extends TestCase
{
    public function testDependency()
    {
        $foo1 = $this->app->make(Foo::class); // new Foo()
        $foo2 = $this->app->make(Foo::class); // new Foo()

        self::assertEquals('Foo', $foo1->foo());
        self::assertEquals('Foo', $foo2->foo());
        self::assertNotSame($foo1, $foo2);
    }

    public function testBind()
    {
        // $person = $this->app->make(Person::class); // new Person()
        // self::assertNotNull($person);

        $this->app->bind(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");
        $person2 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertNotSame($person1, $person2);
    }

    public function testSingleton()
    {
        $this->app->singleton(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // new Person("Eko", "Khannedy"); if not exists
        $person2 = $this->app->make(Person::class); // return existing
        $person3 = $this->app->make(Person::class); // return existing
        $person4 = $this->app->make(Person::class); // return existing

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

    public function testInstance()
    {
        $person = new Person("Eko", "Khannedy");
        $this->app->instance(Person::class, $person);

        $person1 = $this->app->make(Person::class); // $person
        $person2 = $this->app->make(Person::class); // $person
        $person3 = $this->app->make(Person::class); // $person
        $person4 = $this->app->make(Person::class); // $person

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            $foo = $app->make(Foo::class);
            return new Bar($foo);
        });

        $foo = $this->app->make(Foo::class);
        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($foo, $bar1->foo);
        self::assertSame($bar1, $bar2);
    }

    public function testInterfaceToClass()
    {
        // $this->app->singleton(HelloService::class, HelloServiceIndonesia::class);

        $this->app->singleton(HelloService::class, function ($app) {
            return new HelloServiceIndonesia();
        });

        $helloService = $this->app->make(HelloService::class);

        self::assertEquals('Halo Eko', $helloService->hello('Eko'));
    }
}

    public function testDependency()
    {
        $foo1 = $this->app->make(Foo::class); // new Foo()
        $foo2 = $this->app->make(Foo::class); // new Foo()

        self::assertEquals('Foo', $foo1->foo());
        self::assertEquals('Foo', $foo2->foo());
        self::assertNotSame($foo1, $foo2);
    }

Mengubah Cara Membuat Dependency
Saat kita menggunakan function make(key), secara otomatis Laravel akan membuat object, namun kadang kita ingin menentukan cara pembuatan objectnya
Pada kasus seperti ini, kita bisa menggunakan method bind(key, closure)
Kita cukup return kan data yang kita inginkan pada function closure nya
Saat kita menggunakan make(key) untuk mengambil dependencynya, secara otomatis function closure akan dipanggil
Perlu diingat juga, setiap kita memanggil make(key), maka function closure akan selalu dipanggil, jadi bukan menggunakan object yang sama

Kode : Person Class
<?php

namespace App\Data;

class Person
{

    public function __construct(
        public string $firstName,
        public string $lastName,
    ) {
    }
}

Kode : Bind Function
    public function testBind()
    {
        // $person = $this->app->make(Person::class); // new Person()
        // self::assertNotNull($person);

        $this->app->bind(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");
        $person2 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertNotSame($person1, $person2);
    }

Singleton
Sebelumnya ketika menggunakan make(key), maka secara default Laravel akan membuat object baru, atau jika menggunakan bind(key, closure), function closure akan selalu dipanggil
Kadang ada kebutuhan kita membuat object singleton, yaitu satu object saja, dan ketika butuh, kita cukup menggunakan object yang sama
Pada kasus ini, kita bisa menggunakan function singleton(key, closure), maka secara otomatis ketika kita menggunakan make(key), maka object hanya dibuat di awal, selanjutnya object yang sama akan digunakan terus menerus ketika kita memanggil make(key)

Kode : Singleton
    public function testSingleton()
    {
        $this->app->singleton(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // new Person("Eko", "Khannedy"); if not exists
        $person2 = $this->app->make(Person::class); // return existing
        $person3 = $this->app->make(Person::class); // return existing
        $person4 = $this->app->make(Person::class); // return existing

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

Instance
Selain menggunakan function singleton(key, closure), untuk membuat singleton object, kita juga bisa menggunakan object yang sudah ada, dengan cara menggunakan function instance(key, object)
Ketika menggunakan make(key), maka instance object tersebut akan dikembalikan

Kode : Instance
    public function testInstance()
    {
        $person = new Person("Eko", "Khannedy");
        $this->app->instance(Person::class, $person);

        $person1 = $this->app->make(Person::class); // $person
        $person2 = $this->app->make(Person::class); // $person
        $person3 = $this->app->make(Person::class); // $person
        $person4 = $this->app->make(Person::class); // $person

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

Dependency Injection
Sekarang kita tahu bagaimana cara membuat dependency dan juga mendapatkan dependency di Laravel, sekarang bagaimana caranya melakukan dependency injection?
Secara default, jika kita membuat object menggunakan make(key), lalu Laravel mendeteksi terdapat constructor, maka Laravel akan mencoba menggunakan dependency yang sesuai dengan tipe yang dibutuhkan di Laravel

Kode : Mengubah Field Foo di Bar Class
<?php

namespace App\Data;

class Bar
{
    public Foo $foo;

    public function __construct(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function bar(): string
    {
        return $this->foo->foo() . ' and Bar';
    }
}

Kode : Dependency Injection
    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });

        $foo = $this->app->make(Foo::class);
        $bar = $this->app->make(Bar::class);

        self::assertSame("Foo and Bar", $bar->bar());
        self::assertSame($foo, $bar->foo);

    }

Dependency Injection di Closure
Dalam function closure yang kita gunakan, kita juga bisa menggunakan parameter $app untuk mengambil object yang sudah ada di Service Container
Kadang ini mempermudah ketika kita ingin membuat object yang kompleks

Kode : Dependency Injection di Closure
    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            $foo = $app->make(Foo::class);
            return new Bar($foo);
        });

        $foo = $this->app->make(Foo::class);
        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($foo, $bar1->foo);
        self::assertSame($bar1, $bar2);
    }

Binding Interface ke Class
Dalam praktek pengembangan perangkat lunak, hal yang bagus ketika membuat sebuah class yang berhubungan dengan logic adalah, membuat interface sebagai kontrak nya. Harapannya agar implementasi classnya bisa berbeda-beda tanpa harus mengubah kontrak interface nya
Laravel memiliki fitur melakukan binding dari interface ke class secara mudah, kita bisa menggunakan function bind(interface, class) atau bind(interface, closure) dimana closure nya mengembalikan object class implementasinya, atau bisa juga menggunakan function singleton(interface, class) dan singleton(interface, closure)

Kode : HelloService Interface
<?php

namespace App\Services;

interface HelloService
{

    public function hello(string $name): string;
}

Kode : HelloService Implementation
<?php

namespace App\Services;

class HelloServiceIndonesia implements HelloService
{

    public function hello(string $name): string
    {
        return "Halo $name";
    }
}

Kode : Test HelloService
    public function testInterfaceToClass()
    {
        // $this->app->singleton(HelloService::class, HelloServiceIndonesia::class);

        $this->app->singleton(HelloService::class, function ($app) {
            return new HelloServiceIndonesia();
        });

        $helloService = $this->app->make(HelloService::class);

        self::assertEquals('Halo Eko', $helloService->hello('Eko'));
    }

Service Provider
Sekarang kita sudah tahu untuk melakukan dependency injection di Laravel, sekarang pertanyaannya apakah ada best practice dimana melakukan dependency injection tersebut?
Laravel menyediakan fitur bernama Service Provider, dari namanya kita tahu bahwa ini adalah penyedia service atau dependency
Di dalam Service Provider, biasanya kita melakukan registrasi dependency di dalam Service Container
Bahkan semua proses bootstraping atau pembentukan object-object di framework Laravel itu sendiri dilakukan di ServiceProvider, kita bisa lihat saat pertama kali membuat project Laravel, ada banyak sekali file ServiceProvider di namespace App\Providers

Membuat Service Provider
Untuk membuat Service Provider, kita bisa memanfaatkan file artisan untuk melakukan auto generate file nya
Kita bisa menggunakan perintah :
php artisan make:provider NamaServiceProvider

Kode : Membuat Service Provider
php artisan make:provider FooBarServiceProvider

Service Provider Function
Di dalam Service Provider terdapat dua function, yaitu register() dan boot()
Di register(), kita harus melakukan registrasi dependency yang dibutuhkan ke Service Container, jangan melakukan kode selain registrasi dependency di function register(), jika tidak ingin mengalami error dependency belum tersedia
Function boot() dipanggil setelah register() selesai, di sini kita bisa melakukan hal apapun yang diperlukan setelah proses registrasi dependency selesai

Kode : Foo Bar Service Provider
<?php

namespace App\Providers;

use App\Data\Bar;
use App\Data\Foo;
use App\Services\HelloService;
use App\Services\HelloServiceIndonesia;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Support\ServiceProvider;

class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        // echo "FooBarServiceProvider";
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            return new Bar($app->make(Foo::class));
        });
    }

    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    public function provides(): array
    {
        return [HelloService::class, Foo::class, Bar::class];
    }
}

class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        // echo "FooBarServiceProvider";
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            return new Bar($app->make(Foo::class));
        });
    }

Registrasi Service Provider
Setelah kita membuat Service Provider, secara default Service Provider tidak diload oleh Laravel
Untuk memberi tahu Laravel jika kita ingin menambahkan Service Provider, kita perlu menambahkannya pada config di app.php, terdapat key providers yang berisi class-class Service Provider yang akan dijalankan oleh Laravel

Kode : Registrasi Service Provider
        /*
         * Application Service Providers...
         */
        App\Providers\AppServiceProvider::class,
        App\Providers\AuthServiceProvider::class,
        // App\Providers\BroadcastServiceProvider::class,
        App\Providers\EventServiceProvider::class,
        App\Providers\RouteServiceProvider::class,
        App\Providers\FooBarServiceProvider::class,

Kode : Test Service Provider
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use App\Services\HelloService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class FooBarServiceProviderTest extends TestCase
{
    public function testServiceProvider()
    {
        $foo1 = $this->app->make(Foo::class);
        $foo2 = $this->app->make(Foo::class);

        self::assertSame($foo1, $foo2);

        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($bar1, $bar2);

        self::assertSame($foo1, $bar1->foo);
        self::assertSame($foo2, $bar2->foo);
    }

    public function testPropertySingletons()
    {
        $helloService1 = $this->app->make(HelloService::class);
        $helloService2 = $this->app->make(HelloService::class);

        self::assertSame($helloService1, $helloService2);

        self::assertEquals('Halo Eko', $helloService1->hello('Eko'));
    }

    public function testEmpty()
    {
        self::assertTrue(true);
    }
}

class FooBarServiceProviderTest extends TestCase
{
    public function testServiceProvider()
    {
        $foo1 = $this->app->make(Foo::class);
        $foo2 = $this->app->make(Foo::class);

        self::assertSame($foo1, $foo2);

        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($bar1, $bar2);

        self::assertSame($foo1, $bar1->foo);
        self::assertSame($foo2, $bar2->foo);
    }

bindings & singletons Properties
Jika kita hanya butuh melakukan binding sederhana, misal dari interface ke class, kita bisa menggunakan fitur binding via properties di Service Provider
Kita bisa tambahkan property bindings untuk membuat binding, atau
Menggunakan property singletons untuk membuat binding singleton

Kode : Singleton Properties
class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

Kode : Test Singleton Properties
    public function testPropertySingletons()
    {
        $helloService1 = $this->app->make(HelloService::class);
        $helloService2 = $this->app->make(HelloService::class);

        self::assertSame($helloService1, $helloService2);

        self::assertEquals('Halo Eko', $helloService1->hello('Eko'));
    }

Deferred Provider
Secara default semua Service Provider akan di load oleh Laravel, baik itu kita butuhkan atau tidak
Laravel memiliki fitur bernama Deferred Provider, dimana kita bisa menandai sebuah Service Provider agar tidak di load jika tidak dibutuhkan dependency nya
Kita bisa menandai Service Provider kita dengan implement interface DeferrableProvider, lalu implement method provides() yang memberi tahu tipe dependency apa saja yang terdapat di Service Provider ini
Dengan fitur ini, Service Provider hanya akan di load ketika memang dependency nya dibutuhkan
Setiap ada request baru, maka Serive Provider yang sudah Deffered tidak akan di load jika memang tidak dibutuhkan

Kode : Deferrable Provider
class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
        public function provides(): array
    {
        return [HelloService::class, Foo::class, Bar::class];
    }
}

Facades
Sebelumnya kita selalu berinteraksi dengan fitur-fitur Laravel menggunakan dependency injection
Namun kadang ada ketika kita tidak bisa mendapatkan object Application, misal kita membuat kode di class yang bukan bawaan fitur Laravel, pada kasus seperti ini, Facades sangat membantu
Facades adalah class yang menyediakan static akses ke fitur di Service Container atau Application
Laravel menyediakan banyak sekali class Facades, kita akan bahas secara bertahap
Semua class Facades ada di namespace https://laravel.com/api/9.x/Illuminate/Support/Facades.html

Kapan Menggunakan Facades?
Selalu gunakan facades jika memang dibutuhkan saja, jika bisa dilakukan menggunakan dependency injection, selalu gunakan dependency injection
Terlalu banyak menggunakan Facades akan membuat kita tidak sadar bahwa sebuah class banyak sekali memiliki dependency, jika menggunakan dependency injection, kita bisa sadar dengan banyaknya parameter yang terdapat di constructor

Facades vs Helper Function
Di Laravel, selain Facades ada juga Helper Function, bedanya pada Helper Function, tidak dikumpulkan dalam class
Contohnya sebelum kita sudah menggunakan Helper Function bernama config() atau env(), itu adalah Helper function yang terdapat di Laravel
Penggunaan helper function sebenarnya lebih mudah, namun jika dibandingkan dengan Facades, maka penggunaan Facades akan lebih mudah dimengerti secara code

Kode : Config Facades
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Log;
use Tests\TestCase;

class FacadeTest extends TestCase
{
    public function testConfig()
    {
        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);

        var_dump(Config::all());
    }

    public function testConfigDependency()
    {
        $config = $this->app->make('config');
        $firstName3 = $config->get('contoh.author.first');

        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);
        self::assertEquals($firstName1, $firstName3);

        var_dump($config->all());
    }

    public function testFacadeMock()
    {
        Config::shouldReceive('get')
            ->with('contoh.author.first')
            ->andReturn('Eko Keren');

        $firstName = Config::get('contoh.author.first');

        self::assertEquals('Eko Keren', $firstName);
    }
}

class FacadeTest extends TestCase
{
    public function testConfig()
    {
        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);

        var_dump(Config::all());
    }

Bagaimana Facades Bekerja?
Facades sebenarnya adalah class yang menyediakan akses ke dalam dependency yang terdapat di Service Container
Semua class Facades adalah turunan dari class Illuminate\Support\Facades\Facade
Class Facade memiliki sebuah method __callStatic() yang digunakan sebagai magic method yang akan dipanggil ketika kita memanggil static method di Facade, dan akan meneruskan secara otomatis ke dependency yang terdapat di Service Container
Contoh Config::get() sebenarnya akan melakukan pemanggilan method get() di dependency config di Service Container
Untuk nama dependency yang terdapat di Container, kita bisa lihat di method getFacadeAccessor() di class Facade nya

Kode : Config Dependency
    public function testConfigDependency()
    {
        $config = $this->app->make('config');
        $firstName3 = $config->get('contoh.author.first');

        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);
        self::assertEquals($firstName1, $firstName3);

        var_dump($config->all());
    }

Facades Mock
Salah satu kekurangan menggunakan static function biasanya sulit untuk di test, karena mocking static function sangat sulit
Namun untungnya, di Laravel, sudah disediakan function untuk melakukan mocking di Facades, sehingga kita bisa mudah ketika implementasi unit test
Laravel menggunakan library Mockery untuk melakukan Mocking Facades
https://github.com/mockery/mockery

Kode : Facades Mock
    public function testFacadeMock()
    {
        Config::shouldReceive('get')
            ->with('contoh.author.first')
            ->andReturn('Eko Keren');

        $firstName = Config::get('contoh.author.first');

        self::assertEquals('Eko Keren', $firstName);
    }

Daftar Facades
Ada banyak Facades di Laravel, dan seperti dijelaskan sebelumnya, hampir semuanya banyak menggunakan dependency di Service Container
Untuk lebih jelas tentang ada Facades apa saja, kita bisa lihat di sini :
https://laravel.com/docs/9.x/facades#facade-class-reference

Routing
Routing adalah proses menerima HTTP Request dan menjalankan kode sesuai dengan URL yang diminta. Routing biasanya tergantung dari HTTP Method dan URL
Salah satu Service Provider yang paling penting di Laravel adakah RouteServiceProvider.
RouteServiceProvider bertanggung jawab untuk melakukan load data routing dari folder routes. Jika kita hapus Service Provider ini, secara otomatis proses routing tidak akan berjalan
RouteServiceProvider secara default akan me-load data routing dari folder routes

Basic Routing
Salah satu contoh routing yang paling sederhana adalah menggunakan path dan juga closure function sebagai handler nya
Kita bisa menggunakan Facades Route, lalu menggunakan function sesuai dengan HTTP Method nya, misal
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

Kode : Basic Routing
Route::get('/', function () {
    return view('welcome');
});

Route::get('/pzn', function () {
    return "Hello Programmer Zaman Now";
});

Kode : Test Basic Routing
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class RoutingTest extends TestCase
{
    public function testGet()
    {
        $this->get('/pzn')
            ->assertStatus(200)
            ->assertSeeText('Hello Programmer Zaman Now');
    }

    public function testRedirect()
    {
        $this->get('/youtube')
            ->assertRedirect('/pzn');
    }

    public function testFallback()
    {
        $this->get('/tidakada')
            ->assertSeeText('404 by Programmer Zaman Now');

        $this->get('/tidakadalagi')
            ->assertSeeText('404 by Programmer Zaman Now');

        $this->get('/ups')
            ->assertSeeText('404 by Programmer Zaman Now');
    }

    public function testRouteParameter()
    {
        $this->get('/products/1')
            ->assertSeeText('Product 1');

        $this->get('/products/2')
            ->assertSeeText('Product 2');

        $this->get('/products/1/items/XXX')
            ->assertSeeText("Product 1, Item XXX");

        $this->get('/products/2/items/YYY')
            ->assertSeeText("Product 2, Item YYY");
    }

    public function testRouteParameterRegex()
    {
        $this->get('/categories/100')
            ->assertSeeText('Category 100');

        $this->get('/categories/eko')
            ->assertSeeText('404 by Programmer Zaman Now');
    }

    public function testRouteParameterOptional()
    {
        $this->get('/users/khannedy')
            ->assertSeeText('User khannedy');

        $this->get('/users/')
            ->assertSeeText('User 404');
    }

    public function testRouteConflict()
    {
        $this->get('/conflict/budi')
            ->assertSeeText("Conflict budi");

        $this->get('/conflict/eko')
            ->assertSeeText("Conflict Eko Kurniawan Khannedy");
    }

    public function testNamedRoute()
    {
        $this->get('/produk/12345')
            ->assertSeeText('Link http://localhost/products/12345');

        $this->get('/produk-redirect/12345')
            ->assertRedirect('/products/12345');
    }
}

class RoutingTest extends TestCase
{
    public function testGet()
    {
        $this->get('/pzn')
            ->assertStatus(200)
            ->assertSeeText('Hello Programmer Zaman Now');
    }

Redirect
Router juga bisa digunakan untuk melakukan redirect dari satu halaman ke halaman lain
Kita bisa menggunakan function Route::redirect(from, to)

Kode : Redirect
Route::get('/pzn', function () {
    return "Hello Programmer Zaman Now";
});

Route::redirect('/youtube', '/pzn');

Kode : Unit Test Redirect
class RoutingTest extends TestCase
{
    public function testGet()
    {
        $this->get('/pzn')
            ->assertStatus(200)
            ->assertSeeText('Hello Programmer Zaman Now');
    }

    public function testRedirect()
    {
        $this->get('/youtube')
            ->assertRedirect('/pzn');
    }

Melihat Semua Routing
Kadang kita ada kebutuhan melihat semua Routing yang ada di aplikasi Laravel kita
Untuk melihatnya, kita bisa memanfaatkan file artisan dengan perintah :
php artisan route:list

Kode : Melihat Routing

Fallback Route
Apa yang terjadi jika kita melakukan request ke halaman yang tidak ada di aplikasi Laravel kita? Secara otomatis akan mengembalikan error 404
Kadang-kadang kita ingin mengubah tampilan halaman error ketika halaman yang diakses tidak ada
Pada kasus seperti ini, kita bisa membuat fallback route, yaitu callback yang akan dieksekusi ketika tidak ada route yang cocok dengan halaman yang diakses
Kita bisa menggunakan function Route::fallback(closure)

Kode : Fallback Route
Route::redirect('/youtube', '/pzn');

Route::fallback(function () {
    return "404 by Programmer Zaman Now";
});

Kode : Test Fallback Route
    public function testFallback()
    {
        $this->get('/tidakada')
            ->assertSeeText('404 by Programmer Zaman Now');

        $this->get('/tidakadalagi')
            ->assertSeeText('404 by Programmer Zaman Now');

        $this->get('/ups')
            ->assertSeeText('404 by Programmer Zaman Now');
    }

View
Membuat response dari Routeitu sangat mudah, tapi jika misal kita ingin membuat response yang kompleks seperti HTML, maka akan sulit jika kita lakukan di Route
View adalah fitur di Laravel yang digunakan untuk mempermudah dalam pembuatan tampilan halaman web HTML
Dengan View, kita bisa membedakan lokasi logic aplikasi, dengan kode tampilan
Semua View disimpan di folder resources/views

Blade Templating
Laravel menggunakan template engine yang bernama Blade untuk membuat kode View nya, jadi tidak seperti kode PHP biasanya
Detail tentang materi Blade Templating, akan kita bahas di kelas terpisah khusus membahas tentang Blade Templating
Pada materi ini kita hanya akan bahas dasar-dasar nya saja
Blade menggunakan extension blade.php sebagai penamaan file nya, misal index.blade.php

Blade Variable
Salah satu keuntungan menggunakan template dibanding kode PHP langsung adalah, kita bisa memaksa programmer untuk memisahkan logic kode program dengan tampilan (di template)
Di Blade, walaupun kita bisa membuat kode PHP, tapi tidak disarankan menggunakan itu
Cara yang direkomendasikan adalah, kita hanya membuat variable di template blade, lalu mengirim variable tersebut dari luar ketika akan menampilkan template nya
Untuk membuat menampilkan variable di blade template, kita bisa gunakan {{ $nama }}, dinama nanti variable $nama bisa diambil secara otomatis dari data yang kita kirim ketika menampilkan view blade nya

Kode : Hello View
<html>
<body>
<h1>Hello {{$name}}</h1>
</body>
</html>

Rendering View
Setelah kita membuat View, selanjutnya untuk me-render (menampilkan) View tersebut di dalam Router, kita bisa menggunakan function Route::view(uri, template, array) atau menggunakan view(template, array) di dalam closure function Route
Dimana template adalah nama template, tanpa menggunakan blade.php, dan array berisikan data variable yang ingin kita gunakan

Kode : Rendering View
Route::view('/hello', 'hello', ['name' => 'Eko']);

Route::get('/hello-again', function () {
    return view('hello', ['name' => 'Eko']);
});

Route::get('/hello-world', function () {
    return view('hello.world', ['name' => 'Eko']);
});

Test Rendering View
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ViewTest extends TestCase
{
    public function testView()
    {
        $this->get('/hello')
            ->assertSeeText('Hello Eko');

        $this->get('/hello-again')
            ->assertSeeText('Hello Eko');
    }

    public function testNested()
    {
        $this->get('/hello-world')
            ->assertSeeText('World Eko');
    }

    public function testTemplate()
    {
        $this->view('hello', ['name' => 'Eko'])
            ->assertSeeText('Hello Eko');

        $this->view('hello.world', ['name' => 'Eko'])
            ->assertSeeText('World Eko');
    }
}

    public function testView()
    {
        $this->get('/hello')
            ->assertSeeText('Hello Eko');

        $this->get('/hello-again')
            ->assertSeeText('Hello Eko');
    }

Nested View Directory
View juga bisa disimpan di dalam directory lagi di dalam directory views
Hal ini baik ketika kita sudah banyak membuat views, dan ingin melakukan management file views
Namun ketika kita ingin mengambil views nya, kita perlu ganti menjadi titik, tidak menggunakan / (slash)
Misal jika kita buat views di folder admin/profile.blade.php, maka untuk mengaksesnya kita gunakan admin.profile

Kode : View
<html>
<body>
<h1>World {{$name}}</h1>
</body>
</html>

Kode : Route View
Route::get('/hello-world', function () {
    return view('hello.world', ['name' => 'Eko']);
});

    public function testNested()
    {
        $this->get('/hello-world')
            ->assertSeeText('World Eko');
    }

Optimizing Views
Secara default, Blade Template di compile menjadi kode PHP ketika ketika ada request, Laravel akan mengecek apakah hasil compile Blade Template ada atau tidak, jika ada maka akan menggunakannya, jika tidak ada maka akan coba melakukan compile.
Termasuk Laravel juga akan mendeteksi ketika ada perubahan Blade Template.
Kompilasi ketika request masuk akan ada efek buruknya, yaitu performanya jadi lambat karena harus melakukan kompilasi. Oleh karena itu ketika nanti menjalankan aplikasi Laravel di production, ada baiknya melakukan proses kompilasi seluruh blade template terlebih dahulu, agar tidak perlu melakukan kompilasi lagi ketika request masuk

Compiling View
Untuk melakukan compile view atau blade template, kita bisa gunakan perintah :
php artisan view:cache
Semua hasil compile view akan disimpan di folder storage/framework/views
Jika kita ingin menghapus seluruh hasil compile, kita bisa gunakan perintah
php artisan view:clear

Test View Tanpa Routing
Kadang kita juga ingin membuat View tanpa routing, misal untuk mengirim email misalnya
Pada kasus ini, kita bisa melakukan test view secara langsung, tanpa harus membuat Route terlebih dahulu

Kode : Test View Tanpa Route
    public function testTemplate()
    {
        $this->view('hello', ['name' => 'Eko'])
            ->assertSeeText('Hello Eko');

        $this->view('hello.world', ['name' => 'Eko'])
            ->assertSeeText('World Eko');
    }

Static File

Laravel Entry Point
Entry Point atau jalur masuk utama dari Laravel sebenarnya adalah file index.php yang terdapat di folder public
Ketika kita melakukan request /hello, sebenarnya kita mengakses /index.php/hello. Hal ini sudah saya jelaskan di kelas PHP MVC
Lantas bagaimana jika kita ingin menambahkan file static? Misal JavaScript, CSS, HTML, Gambar dan lain-lain?

Static File
Untuk menambahkan static file, kita bisa dengan mudah menambahkan ke dalam folder public
Secara otomatis ketika kita mengakses url ke file static, maka web server akan mencari static file terlebih dahulu, jika tidak ada, maka terakhir akan dikirim request nya ke index.php

Contoh Static File
index.css
index.js

Mengakses Static File
http://127.0.0.1:8000/index.css

Untuk Apa Directory Resources?
Jika diperhatikan, ketika kita membuat project Laravel, terdapat folder resources
Selain views, di dalam resources terdapat folder css dan js
Kenapa ada file css dan js disana?
Jangan bingung dengan ini, ini adalah fitur tambahan Laravel yang memanfaatkan NodeJS, dimana dengan NodeJS, kita bisa melakukan kompilasi file css dan js yang terdapat di folder resources agar di minify (sehingga ukurannya kecil)
Setelah di compile, file js dan css akan tetap di pindahkan ke folder public
Jika teman-teman tidak tahu tentang NodeJS, bisa lanjutkan ikuti materi ini tanpa harus praktek

Kode : Compile Resource dengan NodeJS
npm install
npm run prod

Hasil Compile Static File dengan NodeJS
di folder public ada folder css dan js

Route Parameter
Kadang kita ingin mengirim parameter yang terdapat di bagian dari URL ketika membuat web. Contoh misal parameter untuk id di URL /products/{productId}
Laravel mendukung route parameter, dimana kita bisa menambahkan parameter di route url, dan secara otomatis kita bisa ambil data nya di closure function yang kita gunakan di Route
Untuk membuat route parameter, kita bisa gunakan {nama}. Kita bisa menambah beberapa route parameter, asal namanya berbeda
Data route parameter tersebut akan dikirim secara otomatis pada closure function parameter

Kode : Route Parameter
Route::get('/products/{id}', function ($productId) {
    return "Product $productId";
})->name('product.detail');

Route::get('/products/{product}/items/{item}', function ($productId, $itemId) {
    return "Product $productId, Item $itemId";
})->name('product.item.detail');

Kode : Test Route Parameter
    public function testRouteParameter()
    {
        $this->get('/products/1')
            ->assertSeeText('Product 1');

        $this->get('/products/2')
            ->assertSeeText('Product 2');

        $this->get('/products/1/items/XXX')
            ->assertSeeText("Product 1, Item XXX");

        $this->get('/products/2/items/YYY')
            ->assertSeeText("Product 2, Item YYY");
    }

Regular Expression Constraints
Kadang ada kalanya kita ingin menggunakan Route Parameter, namun parameternya memiliki pola tertentu, misal parameternya hanya boleh angka misalnya
Pada kasus seperti itu, kita bisa menambahkan regular expression di Route Parameter
Caranya kita bisa gunakan function where() setelah pembuatan Route nya

Kode : Route Regular Expression Constraint
Route::get('/categories/{id}', function ($categoryId) {
    return "Category $categoryId";
})->where('id', '[0-9]+')->name('category.detail');

   public function testRouteParameterRegex()
    {
        $this->get('/categories/100')
            ->assertSeeText('Category 100');

        $this->get('/categories/eko')
            ->assertSeeText('404 by Programmer Zaman Now');
    }

Optional Route Parameter
Laravel juga mendukung Route Parameter Optional, artinya parameter nya tidak wajib diisi
Untuk membuat sebuah route parameter menjadi optional, kita bisa tambahkan ? (tanda tanya)
Namun perlu diingat, jika kita menjadikan route parameter nya optional, maka kita wajib menambahkan default value di closure function nya

Kode : Optional Route Parameter
Route::get('/users/{id?}', function ($userId = '404') {
    return "User $userId";
})->name('user.detail');

    public function testRouteParameterOptional()
    {
        $this->get('/users/khannedy')
            ->assertSeeText('User khannedy');

        $this->get('/users/')
            ->assertSeeText('User 404');
    }

Routing Conflict
Saat membuat router dengan parameter, kadang terjadi conflict routing
Di Laravel jika terjadi conflict tidak akan menyebabkan error, namun Laravel akan memprioritaskan router yang pertama kali dibuat

Kode : Routing Conflict
Route::get('/conflict/eko', function () {
    return "Conflict Eko Kurniawan Khannedy";
});

Route::get('/conflict/{name}', function ($name) {
    return "Conflict $name";
});

Kode : Test Routing Conflict
    public function testRouteConflict()
    {
        $this->get('/conflict/budi')
            ->assertSeeText("Conflict budi");

        $this->get('/conflict/eko')
            ->assertSeeText("Conflict Eko Kurniawan Khannedy");
    }

Named Route
Di Laravel, kita bisa menamai Route dengan sebuah nama
Hal ini bagus ketika kita misal nanti butuh mendapatkan informasi tentang route tersebut, misal route url nya, atau melakukan redirect ke route
Dengan menambahkan nama di Route nya, kita bisa menggunakan nama route saja, tanpa khawatir URL nya akan diubah
Untuk menambahkan nama di route, kita cukup gunakan function name()

Kode : Named Route
Route::get('/products/{id}', function ($productId) {
    return "Product $productId";
})->name('product.detail');

Route::get('/products/{product}/items/{item}', function ($productId, $itemId) {
    return "Product $productId, Item $itemId";
})->name('product.item.detail');

Route::get('/categories/{id}', function ($categoryId) {
    return "Category $categoryId";
})->where('id', '[0-9]+')->name('category.detail');

Route::get('/users/{id?}', function ($userId = '404') {
    return "User $userId";
})->name('user.detail');

Kode : Menggunakan Named Route
Route::get('/produk/{id}', function ($id) {
    $link = route('product.detail', ['id' => $id]);
    return "Link $link";
});

Route::get('/produk-redirect/{id}', function ($id) {
    return redirect()->route('product.detail', ['id' => $id]);
});

Kode : Test Named Route
   public function testNamedRoute()
    {
        $this->get('/produk/12345')
            ->assertSeeText('Link http://localhost/products/12345');

        $this->get('/produk-redirect/12345')
            ->assertRedirect('/products/12345');
    }

Controller
Membuat Route memang mudah, tapi jika kita harus menyimpan semua logic aplikasi kita di closure function Route, lama-lama akan sulit untuk dilakukan
Di Laravel kita bisa menggunakan Controller sebagai tempat menyimpan logic dari Route, sehingga tidak perlu kita lakukan lagi di Route
Controller direpresentasikan sebagai class, dan penamaan class nya selalu diakhiri dengan Controller, misal UserController, ProductController, CategoryController, dan lain-lain

Membuat Controller
Untuk membuat Controller, kita bisa membuatnya di namespace App\Http\Controllers, dimana class Controller adalah class turunan dari class Illuminate\Routing\Controller
Agar lebih mudah, kita bisa menggunakan file artisan untuk membuat controller, caranya dengan menggunakan perintah :
php artisan make:controller NamaController

Kode : Membuat Controller
php artisan make:controller HelloController

Membuat Function di Controller
Sebagai pengganti closure function di Route, kita bisa membuat function di Controller, dan menaruh semua logic web kita di function Controller
Selanjutnya, kita bisa meregistrasikan function Controller tersebut ke Route, dengan cara mengganti parameter closure di route dengan array yang berisi class Controller dan juga function name nya

Kode : Function Controller
<?php

namespace App\Http\Controllers;

use App\Services\HelloService;
use Illuminate\Http\Request;

class HelloController extends Controller
{
    private HelloService $helloService;

    public function __construct(HelloService $helloService)
    {
        $this->helloService = $helloService;
    }

    public function hello(Request $request, string $name): string
    {
        //        $request->path();
        //        $request->url();
        //        $request->fullUrl();
        return $this->helloService->hello($name);
    }

    public function request(Request $request): string
    {
        return $request->path() . PHP_EOL .
            $request->url() . PHP_EOL .
            $request->fullUrl() . PHP_EOL .
            $request->method() . PHP_EOL .
            $request->header('Accept');
    }
}

Kode : Route Controller
Route::get('/controller/hello/request', [\App\Http\Controllers\HelloController::class, 'request']);
Route::get('/controller/hello/{name}', [\App\Http\Controllers\HelloController::class, 'hello']);

Kode test
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class HelloControllerTest extends TestCase
{
    public function testHello()
    {
        $this->get('/controller/hello/Eko')
            ->assertSeeText("Halo Eko");
    }

    public function testRequest()
    {
        $this->get('/controller/hello/request', [
            "Accept" => "plain/text"
        ])->assertSeeText("controller/hello/request")
            ->assertSeeText("http://localhost/controller/hello/request")
            ->assertSeeText("GET")
            ->assertSeeText("plain/text");
    }
}

Dependency Injection
Controller mendukung Dependency Injection, pembuatan object Controller, sebenarnya dilakukan oleh Service Container
Dengan demikian, kita bisa menambahkan dependency yang dibutuhkan di Constructor Controller, dan secara otomatis Laravel akan mengambil dependency tersebut dari Service Container

Kode : Hello Controller
<?php

namespace App\Http\Controllers;

use App\Services\HelloService;
use Illuminate\Http\Request;

class HelloController extends Controller
{
    private HelloService $helloService;

    public function __construct(HelloService $helloService)
    {
        $this->helloService = $helloService;
    }

    public function hello(Request $request, string $name): string
    {
        //        $request->path();
        //        $request->url();
        //        $request->fullUrl();
        return $this->helloService->hello($name);
    }

    public function request(Request $request): string
    {
        return $request->path() . PHP_EOL .
            $request->url() . PHP_EOL .
            $request->fullUrl() . PHP_EOL .
            $request->method() . PHP_EOL .
            $request->header('Accept');
    }
}

Kode : Hello Route
Route::get('/controller/hello/{name}', [\App\Http\Controllers\HelloController::class, 'hello']);

    public function testHello()
    {
        $this->get('/controller/hello/Eko')
            ->assertSeeText("Halo Eko");
    }

Request
Di PHP, biasanya ketika kita ingin mendapatkan detail dari request biasanya kita lakukan menggunakan global variable seperti $_GET, $_POST, dan lain-lain
Di Laravel, kita tidak perlu melakukan itu lagi, HTTP Request di bungkus dalam sebuah object dari class Illuminate\Http\Request
Dan kita bisa menambahkan Request di parameter function di Router atau di Controller, dan secara otomatis nanti Laravel akan melakukan dependency injection data Request tersebut

Kode : Request
<?php

namespace App\Http\Controllers;

use App\Services\HelloService;
use Illuminate\Http\Request;

class HelloController extends Controller
{
    private HelloService $helloService;

    public function __construct(HelloService $helloService)
    {
        $this->helloService = $helloService;
    }

    public function hello(Request $request, string $name): string
    {
        //        $request->path();
        //        $request->url();
        //        $request->fullUrl();
        return $this->helloService->hello($name);
    }

    public function request(Request $request): string
    {
        return $request->path() . PHP_EOL .
            $request->url() . PHP_EOL .
            $request->fullUrl() . PHP_EOL .
            $request->method() . PHP_EOL .
            $request->header('Accept');
    }
}

Request Path
Object Request banyak memiliki method yang bisa kita gunakan untuk mendapatkan informasi Path dan URL
$request->path() untuk mendapatkan path, misal http://example.com/foo/bar, akan mengembalikan foo/bar
$request->url() untuk mendapat URL tanpa query parameter
$request->fullUrl() untuk mendapatkan URL dengan query parameter

Request Method
Request juga bisa digunakan untuk mendapatkan informasi HTTP Method
$request->method() akan mengembalikan HTTP Method
$request->isMethod(method) digunakan untuk mengecek apakah request memiliki HTTP method sesuai parameter atau tidak, misal $request->isMethod(‘post’)

Request Method
Untuk mendapatkan informasi HTTP Header, kita juga bisa menggunakan object Request
$request->header(key) digunakan untuk mendapatkan data header dengan key parameter
$request->header(key, default) digunakan untuk mendapatkan data header dengan key parameter, jika tidak ada maka akan mengembalikan data default nya
$request->bearerToken() digunakan untuk mendapatkan informasi token Bearer yang terdapat di header Authorization, dan secara otomatis menghapus prefix Bearer nya

Kode : Request
Route::get('/controller/hello/request', [\App\Http\Controllers\HelloController::class, 'request']);

   public function request(Request $request): string
    {
        return $request->path() . PHP_EOL .
            $request->url() . PHP_EOL .
            $request->fullUrl() . PHP_EOL .
            $request->method() . PHP_EOL .
            $request->header('Accept');
    }

Kode : Test Request
    public function testRequest()
    {
        $this->get('/controller/hello/request', [
            "Accept" => "plain/text"
        ])->assertSeeText("controller/hello/request")
            ->assertSeeText("http://localhost/controller/hello/request")
            ->assertSeeText("GET")
            ->assertSeeText("plain/text");
    }

Request Input
Saat membuat aplikasi web, kita tahu bahwa dalam HTTP Request kita bisa mengirim data, baik itu melalui query parameter, atau melalui body (misal dalam bentuk form)
Biasanya kita menggunakan $_GET atau $_POST atau $_FILES, namun di Laravel, kita bisa menggunakan object Request untuk mendapatkan input yang dikirim melalui HTTP Request

Mengambil Input
Untuk mengambil input yang dikirim oleh user, tidak peduli apapun HTTP Method yang digunakan, dan dari mana asalnya, entah dari body atau query parameter
Untuk mengambil input user, kita bisa gunakan method input(key, default) pada Request, dimana jika key nya tidak ada, maka akan mengembalikan default value di parameter

Kode : Mengambil Input
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class InputController extends Controller
{
    public function hello(Request $request): string
    {
        $name = $request->input('name');
        // $name = $request->name;
        return "Hello $name";
    }

    public function helloFirstName(Request $request): string
    {
        $firstName = $request->input('name.first');
        return "Hello $firstName";
    }

    public function helloInput(Request $request): string
    {
        $input = $request->input();
        return json_encode($input);
    }

    public function helloArray(Request $request): string
    {
        $names = $request->input("products.*.name");
        return json_encode($names);
    }

    public function inputType(Request $request): string
    {
        $name = $request->input('name');
        $married = $request->boolean('married');
        $birthDate = $request->date('birth_date', 'Y-m-d');

        return json_encode([
            'name' => $name,
            'married' => $married,
            'birth_date' => $birthDate->format('Y-m-d')
        ]);
    }

    public function filterOnly(Request $request): string
    {
        $name = $request->only("name.first", "name.last");
        return json_encode($name);
    }

    public function filterExcept(Request $request): string
    {
        $user = $request->except("admin");
        return json_encode($user);
    }

    public function filterMerge(Request $request): string
    {
        $request->merge([
            "admin" => false
        ]);
        $user = $request->input();
        return json_encode($user);
    }
}

class InputController extends Controller
{
    public function hello(Request $request): string
    {
        $name = $request->input('name');
        // $name = $request->name;
        return "Hello $name";
    }

Kode : Router dan Test
Route::get('/input/hello', [\App\Http\Controllers\InputController::class, 'hello']);
Route::post('/input/hello', [\App\Http\Controllers\InputController::class, 'hello']);

class InputControllerTest extends TestCase
{
    public function testInput()
    {
        $this->get('/input/hello?name=Eko')
            ->assertSeeText('Hello Eko');

        $this->post('/input/hello', [
            'name' => 'Eko'
        ])->assertSeeText('Hello Eko');
    }

Nested Input
Salah satu fitur yang powerful di Laravel adalah, kita bisa mengambil input nested hanya dengan menggunakan titik
Misal jika kita menggunakan $requet->input(‘name.first’), maka artinya itu mengambil key first di dalam name, Ini cocok ketika kita kirim request dalam bentuk form atau json

Kode : Nested Input
    public function helloFirstName(Request $request): string
    {
        $firstName = $request->input('name.first');
        return "Hello $firstName";
    }

Route::post('/input/hello/first', [\App\Http\Controllers\InputController::class, 'helloFirstName']);

Kode : Test Nested Input
    public function testInputNested()
    {
        $this->post('/input/hello/first', [
            "name" => [
                "first" => "Eko",
                "last" => "Khannedy"
            ]
        ])->assertSeeText("Hello Eko");
    }

Mengambil Semua Input
Untuk mengambil semua input yang terdapat di HTTP Request, baik itu dari query param ataupun body, kita bisa menggunakan method input() tanpa parameter milik Request
Return value dari method input() ini adalah array

Kode : Mengambil Semua Input
    public function helloInput(Request $request): string
    {
        $input = $request->input();
        return json_encode($input);
    }

Route::post('/input/hello/input', [\App\Http\Controllers\InputController::class, 'helloInput']);

Kode : Test Semua Input
    public function testInputAll()
    {
        $this->post('/input/hello/input', [
            "name" => [
                "first" => "Eko",
                "last" => "Khannedy"
            ]
        ])->assertSeeText("name")->assertSeeText("first")
            ->assertSeeText("last")->assertSeeText("Eko")
            ->assertSeeText("Khannedy");
    }

Mengambil Array Input
Laravel juga memiliki kemampuan untuk mengambil value dari input berupa array
Misal kita bisa gunakan $request->input(‘products.*.name’), artinya kita mengambil semua name yang ada di array products

Kode : Mengambil Array Input
    public function helloArray(Request $request): string
    {
        $names = $request->input("products.*.name");
        return json_encode($names);
    }

Route::post('/input/hello/array', [\App\Http\Controllers\InputController::class, 'helloArray']);

Kode : Test Mengambil Input Array
    public function testInputArray()
    {
        $this->post('/input/hello/array', [
            "products" => [
                [
                    "name" => "Apple Mac Book Pro",
                    "price" => 30000000
                ],
                [
                    "name" => "Samsung Galaxy S10",
                    "price" => 15000000
                ]
            ]
        ])->assertSeeText("Apple Mac Book Pro")
            ->assertSeeText("Samsung Galaxy S10");
    }

Input Query String
Method input() digunakan untuk mengambil data di semua input, baik itu query param ataupun body
Jika misal kita hanya butuh mengambil data di query param, kita bisa menggunakan method $request->query(key)
Atau jika semua query dalam bentuk array, kita bisa gunakan $request->query() tanpa parameter key

Dynamic Properties
Laravel juga mendukung Dynamic Properties yang secara otomatis akan mengambil key dari input Request
Misal ketika kita menggunakan $request->first_name, jika dalam object Request tidak ada property dengan nama $first_name, maka secara otomatis akan mengambil input dengan key first_name

Input Type
Class Request di Laravel memiliki beberapa helper method yang digunakan untuk melakukan konversi input secara otomatis
Ini bisa digunakan untuk mempermudah kita ketika ingin otomatis melakukan konversi input data ke tipe data yang kita inginkan

Boolean
Untuk melakukan konversi tipe data input secara otomatis ke boolean, kita bisa gunakan method boolean(key, default) pada class Request

Date
Untuk melakukan konversi tipe data ke Date secara otomatis, kita bisa gunakan method date(key, pattern, timezone) pada class Request
Laravel menggunakan library Carbon untuk memanipulasi tipe data Date dan Time
https://github.com/briannesbitt/Carbon

Kode : Input Type
    public function inputType(Request $request): string
    {
        $name = $request->input('name');
        $married = $request->boolean('married');
        $birthDate = $request->date('birth_date', 'Y-m-d');

        return json_encode([
            'name' => $name,
            'married' => $married,
            'birth_date' => $birthDate->format('Y-m-d')
        ]);
    }

Route::post('/input/type', [\App\Http\Controllers\InputController::class, 'inputType']);

Kode : Test Input Type
    public function testInputType()
    {
        $this->post('/input/type', [
            'name' => 'Budi',
            'married' => 'true',
            'birth_date' => '1990-10-10'
        ])->assertSeeText('Budi')->assertSeeText("true")->assertSeeText("1990-10-10");
    }

Filter Request Input
Kadang pada saat kita menerima input data dari user, kita ingin secara mudah menerima semua key input, lalu menyimpannya ke database misalnya
Pada kasus seperti ini, kadang sangat berbahaya jika misal user secara tidak sengaja mengirim key yang salah, lalu kita mencoba melakukan update key yang salah itu ke database
Untungnya Laravel memiliki helper method di class Request untuk melakukan filter input

Method Filter Request Input
$request->only([key1, key2]) digunakan untuk mengambil hanya input yang kita sebutkan di parameter
$request->except([key1, key2]) digunakan untuk mengambil semua input, tapi tidak dengan yang kita sebutkan di parameter

Kode : Filter Request Input
    public function filterOnly(Request $request): string
    {
        $name = $request->only("name.first", "name.last");
        return json_encode($name);
    }

    public function filterExcept(Request $request): string
    {
        $user = $request->except("admin");
        return json_encode($user);
    }

Kode : Route Filter Request Input
Route::post('/input/filter/only', [\App\Http\Controllers\InputController::class, 'filterOnly']);
Route::post('/input/filter/except', [\App\Http\Controllers\InputController::class, 'filterExcept']);

Kode : Test Filter Only
    public function testFilterOnly()
    {
        $this->post('/input/filter/only', [
            "name" => [
                "first" => "Eko",
                "middle" => "Kurniawan",
                "last" => "Khannedy"
            ]
        ])->assertSeeText("Eko")->assertSeeText("Khannedy")
            ->assertDontSeeText("Kurniawan");
    }

Kode : Test Filter Except
    public function testFilterExcept()
    {
        $this->post('/input/filter/except', [
            "username" => "khannedy",
            "password" => "rahasia",
            "admin" => "true"
        ])->assertSeeText("khannedy")->assertSeeText("rahasia")
            ->assertDontSeeText("admin");
    }

Merge Input
Kadang-kadang kita ingin menambahkan default input value ketika input tersebut tidak dikirim di request
Kita bisa menggunakan method merge(array) untuk menambah input ke request, dan jika ada key yang sama, otomatis akan diganti
Atau mergeIfMissing(array) untuk menambah input ke request, dan jika input dengan kay yang sama sudah ada, maka akan dibatalkan

Kode : Merge Input
    public function filterMerge(Request $request): string
    {
        $request->merge([
            "admin" => false
        ]);
        $user = $request->input();
        return json_encode($user);
    }

Route::post('/input/filter/merge', [\App\Http\Controllers\InputController::class, 'filterMerge']);

Kode : Test Merge Input
    public function testFilterMerge()
    {
        $this->post('/input/filter/merge', [
            "username" => "khannedy",
            "password" => "rahasia",
            "admin" => "true"
        ])->assertSeeText("khannedy")->assertSeeText("rahasia")
            ->assertSeeText("admin")->assertSeeText("false");
    }

File Storage
Laravel mendukung abstraction untuk management File Storage menggunakan library Flysystem
Dengan menggunakan fitur File Storage ini, kita bisa menyimpan file ke dalam File Storage dan mengubah target dari File Storage tersebut
Misal kita bisa simpan file ke Local tempat terinstall aplikasi Laravel kita, atau bahkan kita bisa simpan file kita di Amazon S3
https://github.com/thephpleague/flysystem

Konfigurasi File Storage
Konfigurasi file storage di Laravel terdapat di file config/filesystems.php
Kita bisa menambahkan banyak konfigurasi File Storage, dan nanti ketika kita akan menyimpan file, kita bisa menentukan File Storage mana yang akan digunakan

Kode : Konfigurasi File Storage
    'disks' => [

        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
            'throw' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
            'throw' => false,
        ],

FileSystem
Implementasi tiap File Storage di Laravel adalah sebuah interface bernama FileSystem
https://laravel.com/api/9.x/Illuminate/Contracts/Filesystem/Filesystem.html
Dan untuk mendapatkan storage, kita bisa gunakan Facade Storage::disk(namaFileStorage)
https://laravel.com/api/9.x/Illuminate/Support/Facades/Storage.html

Kode : FileSystem
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\Storage;
use Tests\TestCase;

class FileStorageTest extends TestCase
{
    public function testStorage()
    {
        $filesystem = Storage::disk("local");

        $filesystem->put("file.txt", "Eko Kurniawan Khannedy");

        $content = $filesystem->get("file.txt");

        self::assertEquals("Eko Kurniawan Khannedy", $content);
    }

    public function testPublic()
    {
        $filesystem = Storage::disk("public");

        $filesystem->put("file.txt", "Eko Kurniawan Khannedy");

        $content = $filesystem->get("file.txt");

        self::assertEquals("Eko Kurniawan Khannedy", $content);
    }
}

    public function testStorage()
    {
        $filesystem = Storage::disk("local");

        $filesystem->put("file.txt", "Eko Kurniawan Khannedy");

        $content = $filesystem->get("file.txt");

        self::assertEquals("Eko Kurniawan Khannedy", $content);
    }

Storage Link
Secara default, File Storage disimpan di folder /storage/app
Laravel memiliki fitur bernama Storage Link, dimana kita bisa membuat link dari /storage/app/public ke /public/storage
Dengan ini maka file yang terdapat di File Storage Public bisa diakses via web
Untuk membuat link nya, kita bisa gunakan perintah :
php artisan storage:link

File Upload
Laravel juga sudah menyediakan method file(key) di Request untuk mengambil request file upload
Tipe data File Upload direpresentasikan dalam class Illuminate\Http\UploadedFile di Laravel
https://laravel.com/api/9.x/Illuminate/Http/UploadedFile.html
File Upload di Laravel terintegrasi dengan baik dengan File Storage

Kode : File Upload
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FileController extends Controller
{
    public function upload(Request $request): string
    {
        $picture = $request->file('picture');

        $picture->storePubliclyAs("pictures", $picture->getClientOriginalName(), "public");

        return "OK " . $picture->getClientOriginalName();
    }
}

Route::post('/file/upload', [\App\Http\Controllers\FileController::class, 'upload'])

Kode : Unit Test File Upload
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Http\UploadedFile;
use Tests\TestCase;

class FileControllerTest extends TestCase
{
    public function testUpload()
    {
        $picture = UploadedFile::fake()->image('khannedy.png');

        $this->post('/file/upload', [
            'picture' => $picture
        ])->assertSeeText("OK khannedy.png");
    }
}

Error CSRF
Secara default, Laravel sudah mengamankan semua pengiriman data melalui Form Post menggunakan CSRF (Cross Site Request Forgery) token
Hal menjadikan kita tidak bisa mengirim data Form Post ke aplikasi Laravel kita jika tidak memiliki token
CSRF Token ini diverifikasi oleh Middleware \App\Http\Middleware\VerifyCsrfToken
Kita bisa men-disable Middleware tersebut di Kernel jika ingin mencoba tanpa CSRF Token

Response
Sebelumnya kita sudah tahu di Route dan Controller, kita bisa mengembalikan data berupa string dan view
Laravel memiliki class Illuminate\Http\Response, yang bisa digunakan untuk representasi dari HTTP Response
Dengan class Response ini, kita bisa mengubah HTTP Response seperti Body, Header, Cookie, dan lain-lain
Untuk membuat object response, kita bisa menggunakan function helper response(content, status, headers)

Kode : Response
<?php

namespace App\Http\Controllers;

use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\Response;
use Symfony\Component\HttpFoundation\BinaryFileResponse;

class ResponseController extends Controller
{
    public function response(Request $request): Response
    {
        return response("hello response");
    }

    public function header(Request $request): Response
    {
        $body = [
            'firstName' => 'Eko',
            'lastName' => 'Khannedy'
        ];

        return response(json_encode($body), 200)
            ->header('Content-Type', 'application/json')
            ->withHeaders([
                'Author' => 'Programmer Zaman Now',
                'App' => 'Belajar Laravel'
            ]);
    }

    public function responseView(Request $request): Response
    {
        return response()
            ->view('hello', ['name' => 'Eko']);
    }

    public function responseJson(Request $request): JsonResponse
    {
        $body = [
            'firstName' => 'Eko',
            'lastName' => 'Khannedy'
        ];
        return response()
            ->json($body);
    }

    public function responseFile(Request $request): BinaryFileResponse
    {
        return response()
            ->file(storage_path('app/public/pictures/Batu.png'));
    }

    public function responseDownload(Request $request): BinaryFileResponse
    {
        return response()
            ->download(storage_path('app/public/pictures/Batu.png'));
    }
}

    public function response(Request $request): Response
    {
        return response("hello response");
    }

Route::get('/response/hello', [\App\Http\Controllers\ResponseController::class, 'response']);

Kode : Test Response
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ResponseControllerTest extends TestCase
{
    public function testResponse()
    {
        $this->get('/response/hello')
            ->assertStatus(200)
            ->assertSeeText('hello response');
    }

    public function testHeader()
    {
        $this->get('/response/header')
            ->assertStatus(200)
            ->assertSeeText('Eko')->assertSeeText('Khannedy')
            ->assertHeader('Content-Type', 'application/json')
            ->assertHeader('Author', 'Programmer Zaman Now')
            ->assertHeader('App', 'Belajar Laravel');
    }

    public function testView()
    {
        $this->get('/response/type/view')
            ->assertSeeText("Hello Eko");
    }

    public function testJson()
    {
        $this->get('/response/type/json')
            ->assertJson([
                "firstName" => 'Eko',
                "lastName" => "Khannedy"
            ]);
    }

    public function testFile()
    {
        $this->get('/response/type/file')
            ->assertHeader('Content-Type', "image/png");
    }

    public function testDownload()
    {
        $this->get('/response/type/download')
            ->assertDownload('Batu.png');
    }
}

    public function testResponse()
    {
        $this->get('/response/hello')
            ->assertStatus(200)
            ->assertSeeText('hello response');
    }

HTTP Response Header
Saat kita membuat Response, kita bisa ubah status dan juga response header
Kita bisa menggunakan function response(content, status, headers)
Atau bisa menggunakan method withHeaders(arrayHeaders) dan header(key, value)

Kode : Response Header
    public function header(Request $request): Response
    {
        $body = [
            'firstName' => 'Eko',
            'lastName' => 'Khannedy'
        ];

        return response(json_encode($body), 200)
            ->header('Content-Type', 'application/json')
            ->withHeaders([
                'Author' => 'Programmer Zaman Now',
                'App' => 'Belajar Laravel'
            ]);
    }

Route::get('/response/header', [\App\Http\Controllers\ResponseController::class, 'header']);

Kode : Test Response Header
    public function testHeader()
    {
        $this->get('/response/header')
            ->assertStatus(200)
            ->assertSeeText('Eko')->assertSeeText('Khannedy')
            ->assertHeader('Content-Type', 'application/json')
            ->assertHeader('Author', 'Programmer Zaman Now')
            ->assertHeader('App', 'Belajar Laravel');
    }

Response Type
Sebelumnya kita sudah melakukan response JSON secara manual, sebenarnya Response sudah memiliki banyak sekali helper method untuk beberapa jenis response type
Untuk menampilkan view, kita bisa menggunakan method view(name, data, status, headers)
Untuk menampilkan JSON, kita bisa menggunakan method json(array, status, headers)
Untuk menampilkan file, kita bisa menggunakan file(pathToFile, headers)
Untuk menampilkan file download, kita bisa menggunakan method download(pathToFile, name, headers)

Kode : Response View dan JSON
    public function responseView(Request $request): Response
    {
        return response()
            ->view('hello', ['name' => 'Eko']);
    }

    public function responseJson(Request $request): JsonResponse
    {
        $body = [
            'firstName' => 'Eko',
            'lastName' => 'Khannedy'
        ];
        return response()
            ->json($body);
    }

Kode : Response File dan Download
    public function responseFile(Request $request): BinaryFileResponse
    {
        return response()
            ->file(storage_path('app/public/pictures/Batu.png'));
    }

    public function responseDownload(Request $request): BinaryFileResponse
    {
        return response()
            ->download(storage_path('app/public/pictures/Batu.png'));
    }

Kode : Route
Route::prefix("/response/type")->group(function () {
    Route::get('/view', [\App\Http\Controllers\ResponseController::class, 'responseView']);
    Route::get('/json', [\App\Http\Controllers\ResponseController::class, 'responseJson']);
    Route::get('/file', [\App\Http\Controllers\ResponseController::class, 'responseFile']);
    Route::get('/download', [\App\Http\Controllers\ResponseController::class, 'responseDownload']);
});

Kode : Test Response View dan JSON
    public function testView()
    {
        $this->get('/response/type/view')
            ->assertSeeText("Hello Eko");
    }

    public function testJson()
    {
        $this->get('/response/type/json')
            ->assertJson([
                "firstName" => 'Eko',
                "lastName" => "Khannedy"
            ]);
    }

Kode : Test Response File dan Download
    public function testFile()
    {
        $this->get('/response/type/file')
            ->assertHeader('Content-Type', "image/png");
    }

    public function testDownload()
    {
        $this->get('/response/type/download')
            ->assertDownload('Batu.png');
    }

Encryption
Laravel memiliki abstraction fitur untuk melakukan encryption, dengan ini kita tidak perlu melakukan enkrip dan dekrip secara manual, kita bisa memanfaatkan fitur ini
Untuk melakukan enkripsi, Laravel membutuhkan key, dimana key tersebut disimpan di config/app.php
Secara default, Laravel akan mengambil key tersebut dari environment APP_KEY, kita bisa cek di file .env

Membuat Encryption Key
Key untuk enkripsi hendaknya dibuat secara random dan secara berkala di ubah
Dan untuk membuat key enkripsi secara random, kita tidak perlu buat secara manual, kita bisa menggunakan bantuan file artisan dengan perintah :
php artisan key:generate
Secara otomatis akan mengisi key APP_KEY di file .env

Melakukan Enkrip dan Dekrip
Untuk melakukan enkrip dan dekrip, kita bisa menggunakan Facade Crypt
https://laravel.com/api/9.x/Illuminate/Support/Facades/Crypt.html

Kode : Encrypt dan Decrypt
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\Crypt;
use Tests\TestCase;

class EncryptionTest extends TestCase
{
    public function testEncryption()
    {
        $encrypt = Crypt::encrypt('Eko Kurniawan');
        var_dump($encrypt);

        $decrypt = Crypt::decrypt($encrypt);

        self::assertEquals('Eko Kurniawan', $decrypt);
    }
}
