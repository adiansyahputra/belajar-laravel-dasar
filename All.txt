Pengenalan Laravel
Laravel adalah framework di PHP untuk membuat Web atau API
Laravel pertama kali dibuat oleh Taylor Otwell tahun 2011
Laravel adalah framework yang open source dan gratis, sehingga kita bisa menggunakannya tanpa biaya dan juga bisa berkontribusi ke projectnya
https://laravel.com/
https://github.com/laravel/laravel

Kenapa Laravel?
Saat ini Laravel adalah framework paling populer di PHP
Banyak perusahaan yang sudah menggunakan Laravel sebagai framework pilihan ketika menggunakan PHP
Laravel juga memiliki ekosistem yang sangat besar, terutama dari ekosistem teknologi pendukung, sehingga ketika menggunakan Laravel, kita bisa mengintegrasikan dengan teknologi pendukung nya dengan lebih mudah

Model View Controller
Laravel sendiri membawa konsep MVC (Model View Controller)
Sehingga jika kita sudah terbiasa dengan konsep tersebut, kita akan dengan mudah menggunakan Laravel
Detail dari konsep MVC itu sendiri sudah dibahas di kelas PHP MVC

Versi Laravel
https://laravel.com/docs/master/releases

Library
Laravel sendiri sebenarnya tidak membuat semua bagian pada framework nya sendiri
Beberapa bagian menggunakan library yang sudah populer di PHP, dan sudah kita bahas di roadmap kelas PHP
Contohnya untuk project management, Laravel menggunakan Composer
Untuk Logging, Laravel menggunakan Monolog
Untuk Unit Test, Laravel menggunakan PHPUnit
Dan lain-lain

Server Requirements
PHP >= 8.0
BCMath PHP Extension
Ctype PHP Extension
cURL PHP Extension
DOM PHP Extension
Fileinfo PHP Extension
JSON PHP Extension
Mbstring PHP Extension
OpenSSL PHP Extension
PCRE PHP Extension
PDO PHP Extension
Tokenizer PHP Extension
XML PHP Extension

Membuat Project
Laravel menggunakan Composer untuk project management nya
Dan untuk membuat projectnya pun kita bisa menggunakan Composer dengan perintah :
composer create-project laravel/laravel=version nama-folder
https://packagist.org/packages/laravel/laravel

Struktur Project

Menjalankan Laravel

Artisan
Saat kita membuat project Laravel, laravel sendiri sudah menyediakan secara otomatis sebuah file bernama artisan
File artisan ini sendiri sebenarnya adalah file yang berisi kode php
Kita bisa menggunakan perintah “php artisan” untuk melihat semua feature yang bisa dilakukan oleh file artisan

Menjalankan Laravel
File artisan bisa digunakan untuk melakukan banyak hal, salah satunya menjalankan aplikasi laravel ketika proses development
Untuk menjalankan aplikasi laravel dalam mode development, kita bisa gunakan perintah :
php artisan serve

Git
Saat kita membuat project Laravel, kita direkomendasikan untuk menggunakan Git sebagai source code management nya
Kita juga bisa melihat ada file seperti .gitignore yang otomatis dibuat di project Laravel, untuk memberi tahu, bagian mana yang tidak perlu di commit ke dalam Git repository
Jika teman-teman belum terbiasa dengan Git, saya sarankan mengikuti kelas Git saya sudah saya buat
https://kelas.programmerzamannow.com/p/git-untuk-pemula-sampai-mahir

Artisan
Saat membuat project Laravel, Laravel menyediakan sebuah file bernama artisan
File artisan ini adalah kode PHP yang bisa digunakan untuk banyak hal, kita akan bahas fitur-fitur file artisan ini secara bertahap di materi-materi selanjutnya

Melihat Semua Fitur File Artisan
Untuk melihat semua fitur file artisan, kita bisa gunakan perintah :
php artisan
Secara otomatis kita bisa lihat semua fitur yang terdapat di file artisan

Melihat Detail Informasi
Untuk melihat detail informasi perintah yang terdapat di file artisan, kita bisa gunakan perintah :
php artisan perintah --help
Contoh :
php artisan serve --help

Request Lifecycle
Sebelum kita membuat kode program menggunakan Laravel, ada baiknya kita perlu tahu cara kerja Laravel itu sendiri
Terutama bagaimana alur hidup dari request yang kita lakukan ke aplikasi Laravel
Jika teman-teman sudah mengikuti kelas PHP MVC yang saya buat, harusnya tidak akan terlalu bingung, karena hampir sama cara kerja nya

public/index.php
Entry point pertama dari aplikasi Laravel adalah sebuah file index.php yang terdapat di folder public
Semua request yang masuk ke aplikasi Laravel, maka akan masuk melalui file ini
File ini sengaja disimpan di dalam folder public tersendiri, agar file-file kode program lainnya tidak bisa diakses via URL
Ini file index.php sebenarnya tidak ada yang kompleks, hanya me-load framework Laravel, dan menjalankan kode program yang kita buat

Kernel
Dari index.php, request akan dilanjutkan ke class Kernel
Di Laravel, terdapat dua jenis Kernel, HTTP Kernel, dan Console Kernel. HTTP Kernel digunakan untuk menangani request berupa HTTP, sedangkan Console Kernel digunakan untuk menangani request berupa perintah console
Pada kelas ini kita bahas tentang HTTP Kernel, jadi ketika request web masuk ke index.php, maka request akan dilanjutkan ke HTTP Kernel

Service Provider
Kernel sendiri sebenarnya adalah core dari logic aplikasi, dimana di dalam Kernel, request yang masuk di tangani sampai mendapatkan response
Kernel melakukan beberapa hal, pertama Kernel melakukan proses bootstraping, yaitu me-load yang namanya Service Provider, yang akan kita bahas di materi terpisah
Laravel akan melakukan iterasi semua Service Provider dan melakukan proses registrasi dan juga bootstraping untuk semua Service Provider
Service Provider ini lah yang bertanggung jawab melakukan bootstraping semua komponen di Laravel, seperti database, queue, validation, routing dan lain-lain

Testing
Laravel menggunakan PHPUnit untuk implementasi unit test nya
Secara garis besar, di Laravel terdapat dua jenis test, unit test dan feature test / integration test

Unit Test
Untuk unit test, kita bisa membuat class unit test seperti menggunakan PHP Unit biasanya
Yaitu dengan membuat class turunan dari PHPUnit\Framework\TestCase
Jika kita perlu membuat test tanpa harus menggunakan fitur Laravel, maka kita cukup buat Unit Test saja

Integration Test
Laravel memiliki fitur yang mempermudah kita ketika membuat integration test
Bedanya dari unit test, di integration test, aplikasi laravel bisa diakses dengan mudah, misal kita nanti mau memanggil Database, Controller, dan lain-lain
Untuk membuat Integration Test, kita cukup membuat class turunan dari Illuminate\Foundation\Testing\TestCase
Integration Test akan lebih lambat dibandingkan Unit Test, karena kita butuh me-load framework Laravel terlebih dahulu
Dan jika kita membutuhkan fitur Laravel, maka kita wajib menggunakan Integration Test

Membuat Test
Untuk membuat Integration Test, kita bisa lakukan manual, atau kita bisa gunakan file artisan menggunakan perintah :
php artisan make:test NamaTest
Secara otomatis akan masuk ke folder tests/Feature
Jika kita ingin membuat Unit Test, kita bisa gunakan perintah :
php artisan make:test NamaTest --unit
Secara otomatis akan masuk ke folder tests/Unit

Menjalankan Test
Untuk menjalankan test, kita bisa gunakan PHPUnit seperti biasanya
Atau jika ingin menjalankan semua test, bisa menggunakan file artisan dengan perintah :
php artisan test

Environment
Saat kita membuat aplikasi, kadang kita perlu menyimpan nilai konfigurasi di environment variable
Laravel memiliki fitur untuk memudahkan kita mengambil data dari environment variable
Kita bisa menggunakan function env(key) atau Env::get(key) untuk mendapatkan nilai dari environment variable
Internal implementasi dari Environment variable di Laravel menggunakan library https://github.com/vlucas/phpdotenv

Kode : Environment Variable
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Env;
use Tests\TestCase;

class EnvironmentTest extends TestCase
{
    public function testGetEnv()
    {
        $youtube = env('YOUTUBE');

        self::assertEquals('Programmer Zaman Now', $youtube);
    }

    public function testDefaultEnv()
    {
        $author = Env::get('AUTHOR', 'Eko');

        self::assertEquals('Eko', $author);
    }


}

Kode : Test Environment Variable

File .env
Selain membaca dari environment variable, Laravel juga memiliki kemampuan untuk membaca nilai dari file .env yang terdapat di project Laravel
Ini lebih mudah dibandingkan mengubah environment variable di sistem operasi
Kita cukup menambah environment variable ke file .env
File .env secara default di ignore di Git project Laravel, oleh karena itu, kita bisa menambahkan konfigurasi di local tanpa takut ter-commit ke Git Repository

Kode : File .env
YOUTUBE='Programmer Zaman Now'

APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:8yKx5XZ8KxlLe1ZyOv6OcVLHKXA1AtRpq8RHi86d2f0=
APP_DEBUG=true
APP_URL=http://localhost

Default Value
Laravel mendukung default value untuk environment variable
Default value adalah nilai yang akan digunakan ketika environment variable yang kita ambil tidak tersedia
Kita bisa menggunakan function env(key, default) atau Env::get(key, default)

Kode : Default Environment Value
    public function testDefaultEnv()
    {
        $author = Env::get('AUTHOR', 'Eko');

        self::assertEquals('Eko', $author);
    }

Application Environment
Saat membuat aplikasi, kadang kita ingin menentukan saat ini sedang berjalan di environment mana, misal di local, di dev, di staging, di qa atau di production
Di Laravel, hal ini biasanya dilakukan dengan menggunakan environment variable APP_ENV
Dan untuk mengecek saat ini sedang berjalan di environment apa, kita bisa menggunakan function App::environment(value) atau App::environment([value1, value2]), dimana akan return true jika benar

Kode : PHP Unit
        <env name="APP_ENV" value="testing"/>
        <env name="BCRYPT_ROUNDS" value="4"/>
        <env name="CACHE_DRIVER" value="array"/>

Kode : Application Environment
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\App;
use Tests\TestCase;

class AppEnvironmentTest extends TestCase
{
    public function testAppEnv() {
        if(App::environment(['testing', 'prod', 'dev'])){
            // kode program kita
            self::assertTrue(true);
        }
    }
}

Configuration
Environment variable cocok digunakan untuk jenis konfigurasi yang memang butuh berubah-ubah nilainya, dan terintegrasi dengan baik dengan environment variable di sistem operasi
Laravel juga mendukung penulisan konfigurasi dengan menggunakan PHP Code, konfigurasi ini biasanya digunakan ketika memang dibutuhkan tidak terlalu sering berubah, dan biasanya pengaturannya hampir sama untuk tiap lokasi dijalankan aplikasi
Namun saat menggunakan fitur Laravel Configuration, kita juga tetap bisa mengakses Environment Variable

Folder Configuration
Laravel menyimpan semua konfigurasi di folder config yang terdapat di project
Dan prefix dari konfigurasi diawali dengan file php yang terdapat di project tersebut

Membuat File Konfigurasi
Untuk membuat file konfigurasi, kita cukup membuat file php di dalam folder config
Lalu di dalam file tersebut, kita cukup return konfigurasi dalam bentuk array

Kode : contoh.php
<?php

return [
    "author" => [
        "first" => "adi",
        "last" => "putra"
    ],
    "email" => "adi@gmail.com",
    "web" => "hoho.com"
];

Mengambil Konfigurasi
Untuk mengambil konfigurasi di file konfigurasi, kita bisa menggunakan function config(key, default)
Dimana pembuatan key pada config diawali dengan nama file, lalu diikuti dengan key yang terdapat di dalam return value nya
Tiap nested array menggunakan . (titik)
Misal contoh.author.first, artinya kita ambil konfigurasi dari file contoh.php, lalu ambil data array key author, dan di dalamnya kita ambil data key first
Sama seperti function env(), function config() juga memiliki parameter default value jika key konfigurasinya tidak tersedia

Kode : Config Test
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ConfigurationTest extends TestCase
{
    public function testConfig()
    {
        $firstName = config("contoh.author.first");
        $lastName = config("contoh.author.last");
        $email = config("contoh.email");
        $web = config("contoh.web");

        self::assertEquals("adi", $firstName);
        self::assertEquals("putra", $lastName);
        self::assertEquals("adi@gmail.com", $email);
        self::assertEquals("hoho.com", $web);
    }
}

Configuration Cache
Saat kita membuat terlalu banyak file konfigurasi, lama-lama maka akan membuat proses baca konfigurasi menjadi lambat karena Laravel harus membaca file setiap kali kita mengambil konfigurasi
Pada saat proses development, hal ini mungkin bukan masalah, namun jika sudah masuk ke production, maka ini bisa memperlambat performa aplikasi Laravel kita
Laravel memiliki fitur untuk meng-cache data konfigurasi yang kita buat menjadi satu file sehingga proses membacanya lebih cepat karena datanya langsung di load saat aplikasi berjalan
Untuk membuat configuration cache, kita bisa gunakan perintah :
php artisan config:cache

Lokasi Configuration Cache

Hapus Configuration Cache
Ketika file cache sudah dibuat, jika kita menambah konfigurasi di file php yang terdapat di folder config, maka config tersebut tidak akan bisa diakses
Hal ini karena Laravel akan selalu menggunakan configuration cache jika ada, oleh karena itu kita bisa buat ulang cache nya, atau jika ingin menghapus cache nya, kita bisa gunakan perintah :
php artisan config:clear

Dependency Injection
Di dalam pengembangan perangkat lunak, ada konsep yang namanya Dependency Injection
Dependency Injection adalah teknik dimana sebuah object menerima object lain yang dibutuhka atau istilahnya dependencies
Saat kita membuat object, sering sekali kita membuat object yang butuh object lain
https://en.wikipedia.org/wiki/Dependency_injection

Kode : Foo Class
<?php

namespace App\Data;

class Foo
{
    public function foo(): string
    {
        return "Foo";
    }
}

Kode : Bar Class
<?php

namespace App\Data;

class Bar
{
    public Foo $foo;

    public function __construct(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function bar(): string
    {
        return $this->foo->foo() . ' and Bar';
    }
}

Foo dan Bar
Dari class Foo dan Bar kita tahu bahwa Bar membutuhkan Foo, artinya Bar depends-on Foo, atau Foo adalah dependency untuk Bar
Dependency Injection berarti kita perlu memasukkan object Foo ke dalam Bar, sehingga Bar bisa menggunakan object Foo
Pada kode Foo dan Bar kita menggunakan Constructor untuk melakukan injection (memasukkan dependency), sebenarnya caranya tidak hanya menggunakan Constructor, bisa menggunakan Attribute atau Function, namun sangat direkomendasikan menggunakan Constructor agar bisa terlihat jelas dependencies nya dan kita tidak lupa menambahkan dependencies nya

Kode : Dependency Injection
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class DependencyInjectionTest extends TestCase
{
    public function testDependencyInjection()
    {
        $foo = new Foo();
        $bar = new Bar($foo);
        //        $bar->setFoo($foo);
        //        $bar->foo = $foo;

        self::assertEquals('Foo and Bar', $bar->bar());
    }
}

Service Container
Sebelumnya kita sudah mencoba melakukan Dependency Injection secara manual
Laravel memiliki fitur Dependency Injection secara otomatis, dan ini wajib dikuasai agar lebih mudah membuat aplikasi menggunakan Laravel
Di Laravel fitur ini bernama Service Container, dimana Service Container ini merupakan fitur yang digunakan untuk manajemen dependencies dan juga dependency injection

Application Class
Service Container di Laravel direpresentasikan dalam class bernama Application
Kita tidak perlu membuat class Application secara manual, karena semua sudah dilakukan secara otomatis oleh framework Laravel
Di semua project Laravel, hampir disemua bagian terdapat field $app yang merupakan instance dari Application
https://laravel.com/api/9.x/Illuminate/Foundation/Application.html

Membuat Dependency
Dengan menggunakan Service Container, kita tidak perlu membuat object secara manual lagi menggunakan kata kunci new
Kita bisa menggunakan function make(key) yang terdapat di class Application untuk membuat dependency secara otomatis
Saat kita menggunakan make(key), object akan selalu dibuat baru, jadi harap hati-hati ketika menggunakannya, karena dia bukan menggunakan object yang sama

Kode : Membuat Dependency
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use App\Data\Person;
use App\Services\HelloService;
use App\Services\HelloServiceIndonesia;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class ServiceContainerTest extends TestCase
{
    public function testDependency()
    {
        $foo1 = $this->app->make(Foo::class); // new Foo()
        $foo2 = $this->app->make(Foo::class); // new Foo()

        self::assertEquals('Foo', $foo1->foo());
        self::assertEquals('Foo', $foo2->foo());
        self::assertNotSame($foo1, $foo2);
    }

    public function testBind()
    {
        // $person = $this->app->make(Person::class); // new Person()
        // self::assertNotNull($person);

        $this->app->bind(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");
        $person2 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertNotSame($person1, $person2);
    }

    public function testSingleton()
    {
        $this->app->singleton(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // new Person("Eko", "Khannedy"); if not exists
        $person2 = $this->app->make(Person::class); // return existing
        $person3 = $this->app->make(Person::class); // return existing
        $person4 = $this->app->make(Person::class); // return existing

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

    public function testInstance()
    {
        $person = new Person("Eko", "Khannedy");
        $this->app->instance(Person::class, $person);

        $person1 = $this->app->make(Person::class); // $person
        $person2 = $this->app->make(Person::class); // $person
        $person3 = $this->app->make(Person::class); // $person
        $person4 = $this->app->make(Person::class); // $person

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            $foo = $app->make(Foo::class);
            return new Bar($foo);
        });

        $foo = $this->app->make(Foo::class);
        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($foo, $bar1->foo);
        self::assertSame($bar1, $bar2);
    }

    public function testInterfaceToClass()
    {
        // $this->app->singleton(HelloService::class, HelloServiceIndonesia::class);

        $this->app->singleton(HelloService::class, function ($app) {
            return new HelloServiceIndonesia();
        });

        $helloService = $this->app->make(HelloService::class);

        self::assertEquals('Halo Eko', $helloService->hello('Eko'));
    }
}

    public function testDependency()
    {
        $foo1 = $this->app->make(Foo::class); // new Foo()
        $foo2 = $this->app->make(Foo::class); // new Foo()

        self::assertEquals('Foo', $foo1->foo());
        self::assertEquals('Foo', $foo2->foo());
        self::assertNotSame($foo1, $foo2);
    }

Mengubah Cara Membuat Dependency
Saat kita menggunakan function make(key), secara otomatis Laravel akan membuat object, namun kadang kita ingin menentukan cara pembuatan objectnya
Pada kasus seperti ini, kita bisa menggunakan method bind(key, closure)
Kita cukup return kan data yang kita inginkan pada function closure nya
Saat kita menggunakan make(key) untuk mengambil dependencynya, secara otomatis function closure akan dipanggil
Perlu diingat juga, setiap kita memanggil make(key), maka function closure akan selalu dipanggil, jadi bukan menggunakan object yang sama

Kode : Person Class
<?php

namespace App\Data;

class Person
{

    public function __construct(
        public string $firstName,
        public string $lastName,
    ) {
    }
}

Kode : Bind Function
    public function testBind()
    {
        // $person = $this->app->make(Person::class); // new Person()
        // self::assertNotNull($person);

        $this->app->bind(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");
        $person2 = $this->app->make(Person::class); // closure() // new Person("Eko", "Khannedy");

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertNotSame($person1, $person2);
    }

Singleton
Sebelumnya ketika menggunakan make(key), maka secara default Laravel akan membuat object baru, atau jika menggunakan bind(key, closure), function closure akan selalu dipanggil
Kadang ada kebutuhan kita membuat object singleton, yaitu satu object saja, dan ketika butuh, kita cukup menggunakan object yang sama
Pada kasus ini, kita bisa menggunakan function singleton(key, closure), maka secara otomatis ketika kita menggunakan make(key), maka object hanya dibuat di awal, selanjutnya object yang sama akan digunakan terus menerus ketika kita memanggil make(key)

Kode : Singleton
    public function testSingleton()
    {
        $this->app->singleton(Person::class, function ($app) {
            return new Person("Eko", "Khannedy");
        });

        $person1 = $this->app->make(Person::class); // new Person("Eko", "Khannedy"); if not exists
        $person2 = $this->app->make(Person::class); // return existing
        $person3 = $this->app->make(Person::class); // return existing
        $person4 = $this->app->make(Person::class); // return existing

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

Instance
Selain menggunakan function singleton(key, closure), untuk membuat singleton object, kita juga bisa menggunakan object yang sudah ada, dengan cara menggunakan function instance(key, object)
Ketika menggunakan make(key), maka instance object tersebut akan dikembalikan

Kode : Instance
    public function testInstance()
    {
        $person = new Person("Eko", "Khannedy");
        $this->app->instance(Person::class, $person);

        $person1 = $this->app->make(Person::class); // $person
        $person2 = $this->app->make(Person::class); // $person
        $person3 = $this->app->make(Person::class); // $person
        $person4 = $this->app->make(Person::class); // $person

        self::assertEquals('Eko', $person1->firstName);
        self::assertEquals('Eko', $person2->firstName);
        self::assertSame($person1, $person2);
    }

Dependency Injection
Sekarang kita tahu bagaimana cara membuat dependency dan juga mendapatkan dependency di Laravel, sekarang bagaimana caranya melakukan dependency injection?
Secara default, jika kita membuat object menggunakan make(key), lalu Laravel mendeteksi terdapat constructor, maka Laravel akan mencoba menggunakan dependency yang sesuai dengan tipe yang dibutuhkan di Laravel

Kode : Mengubah Field Foo di Bar Class
<?php

namespace App\Data;

class Bar
{
    public Foo $foo;

    public function __construct(Foo $foo)
    {
        $this->foo = $foo;
    }

    public function bar(): string
    {
        return $this->foo->foo() . ' and Bar';
    }
}

Kode : Dependency Injection
    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });

        $foo = $this->app->make(Foo::class);
        $bar = $this->app->make(Bar::class);

        self::assertSame("Foo and Bar", $bar->bar());
        self::assertSame($foo, $bar->foo);

    }

Dependency Injection di Closure
Dalam function closure yang kita gunakan, kita juga bisa menggunakan parameter $app untuk mengambil object yang sudah ada di Service Container
Kadang ini mempermudah ketika kita ingin membuat object yang kompleks

Kode : Dependency Injection di Closure
    public function testDependencyInjection()
    {
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            $foo = $app->make(Foo::class);
            return new Bar($foo);
        });

        $foo = $this->app->make(Foo::class);
        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($foo, $bar1->foo);
        self::assertSame($bar1, $bar2);
    }

Binding Interface ke Class
Dalam praktek pengembangan perangkat lunak, hal yang bagus ketika membuat sebuah class yang berhubungan dengan logic adalah, membuat interface sebagai kontrak nya. Harapannya agar implementasi classnya bisa berbeda-beda tanpa harus mengubah kontrak interface nya
Laravel memiliki fitur melakukan binding dari interface ke class secara mudah, kita bisa menggunakan function bind(interface, class) atau bind(interface, closure) dimana closure nya mengembalikan object class implementasinya, atau bisa juga menggunakan function singleton(interface, class) dan singleton(interface, closure)

Kode : HelloService Interface
<?php

namespace App\Services;

interface HelloService
{

    public function hello(string $name): string;
}

Kode : HelloService Implementation
<?php

namespace App\Services;

class HelloServiceIndonesia implements HelloService
{

    public function hello(string $name): string
    {
        return "Halo $name";
    }
}

Kode : Test HelloService
    public function testInterfaceToClass()
    {
        // $this->app->singleton(HelloService::class, HelloServiceIndonesia::class);

        $this->app->singleton(HelloService::class, function ($app) {
            return new HelloServiceIndonesia();
        });

        $helloService = $this->app->make(HelloService::class);

        self::assertEquals('Halo Eko', $helloService->hello('Eko'));
    }

Service Provider
Sekarang kita sudah tahu untuk melakukan dependency injection di Laravel, sekarang pertanyaannya apakah ada best practice dimana melakukan dependency injection tersebut?
Laravel menyediakan fitur bernama Service Provider, dari namanya kita tahu bahwa ini adalah penyedia service atau dependency
Di dalam Service Provider, biasanya kita melakukan registrasi dependency di dalam Service Container
Bahkan semua proses bootstraping atau pembentukan object-object di framework Laravel itu sendiri dilakukan di ServiceProvider, kita bisa lihat saat pertama kali membuat project Laravel, ada banyak sekali file ServiceProvider di namespace App\Providers

Membuat Service Provider
Untuk membuat Service Provider, kita bisa memanfaatkan file artisan untuk melakukan auto generate file nya
Kita bisa menggunakan perintah :
php artisan make:provider NamaServiceProvider

Kode : Membuat Service Provider
php artisan make:provider FooBarServiceProvider

Service Provider Function
Di dalam Service Provider terdapat dua function, yaitu register() dan boot()
Di register(), kita harus melakukan registrasi dependency yang dibutuhkan ke Service Container, jangan melakukan kode selain registrasi dependency di function register(), jika tidak ingin mengalami error dependency belum tersedia
Function boot() dipanggil setelah register() selesai, di sini kita bisa melakukan hal apapun yang diperlukan setelah proses registrasi dependency selesai

Kode : Foo Bar Service Provider
<?php

namespace App\Providers;

use App\Data\Bar;
use App\Data\Foo;
use App\Services\HelloService;
use App\Services\HelloServiceIndonesia;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Support\ServiceProvider;

class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        // echo "FooBarServiceProvider";
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            return new Bar($app->make(Foo::class));
        });
    }

    /**
     * Bootstrap services.
     *
     * @return void
     */
    public function boot()
    {
        //
    }

    public function provides(): array
    {
        return [HelloService::class, Foo::class, Bar::class];
    }
}

class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

    /**
     * Register services.
     *
     * @return void
     */
    public function register()
    {
        // echo "FooBarServiceProvider";
        $this->app->singleton(Foo::class, function ($app) {
            return new Foo();
        });
        $this->app->singleton(Bar::class, function ($app) {
            return new Bar($app->make(Foo::class));
        });
    }

Registrasi Service Provider
Setelah kita membuat Service Provider, secara default Service Provider tidak diload oleh Laravel
Untuk memberi tahu Laravel jika kita ingin menambahkan Service Provider, kita perlu menambahkannya pada config di app.php, terdapat key providers yang berisi class-class Service Provider yang akan dijalankan oleh Laravel

Kode : Registrasi Service Provider
        /*
         * Application Service Providers...
         */
        App\Providers\AppServiceProvider::class,
        App\Providers\AuthServiceProvider::class,
        // App\Providers\BroadcastServiceProvider::class,
        App\Providers\EventServiceProvider::class,
        App\Providers\RouteServiceProvider::class,
        App\Providers\FooBarServiceProvider::class,

Kode : Test Service Provider
<?php

namespace Tests\Feature;

use App\Data\Bar;
use App\Data\Foo;
use App\Services\HelloService;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Tests\TestCase;

class FooBarServiceProviderTest extends TestCase
{
    public function testServiceProvider()
    {
        $foo1 = $this->app->make(Foo::class);
        $foo2 = $this->app->make(Foo::class);

        self::assertSame($foo1, $foo2);

        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($bar1, $bar2);

        self::assertSame($foo1, $bar1->foo);
        self::assertSame($foo2, $bar2->foo);
    }

    public function testPropertySingletons()
    {
        $helloService1 = $this->app->make(HelloService::class);
        $helloService2 = $this->app->make(HelloService::class);

        self::assertSame($helloService1, $helloService2);

        self::assertEquals('Halo Eko', $helloService1->hello('Eko'));
    }

    public function testEmpty()
    {
        self::assertTrue(true);
    }
}

class FooBarServiceProviderTest extends TestCase
{
    public function testServiceProvider()
    {
        $foo1 = $this->app->make(Foo::class);
        $foo2 = $this->app->make(Foo::class);

        self::assertSame($foo1, $foo2);

        $bar1 = $this->app->make(Bar::class);
        $bar2 = $this->app->make(Bar::class);

        self::assertSame($bar1, $bar2);

        self::assertSame($foo1, $bar1->foo);
        self::assertSame($foo2, $bar2->foo);
    }

bindings & singletons Properties
Jika kita hanya butuh melakukan binding sederhana, misal dari interface ke class, kita bisa menggunakan fitur binding via properties di Service Provider
Kita bisa tambahkan property bindings untuk membuat binding, atau
Menggunakan property singletons untuk membuat binding singleton

Kode : Singleton Properties
class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
    public array $singletons = [
        HelloService::class => HelloServiceIndonesia::class
    ];

Kode : Test Singleton Properties
    public function testPropertySingletons()
    {
        $helloService1 = $this->app->make(HelloService::class);
        $helloService2 = $this->app->make(HelloService::class);

        self::assertSame($helloService1, $helloService2);

        self::assertEquals('Halo Eko', $helloService1->hello('Eko'));
    }

Deferred Provider
Secara default semua Service Provider akan di load oleh Laravel, baik itu kita butuhkan atau tidak
Laravel memiliki fitur bernama Deferred Provider, dimana kita bisa menandai sebuah Service Provider agar tidak di load jika tidak dibutuhkan dependency nya
Kita bisa menandai Service Provider kita dengan implement interface DeferrableProvider, lalu implement method provides() yang memberi tahu tipe dependency apa saja yang terdapat di Service Provider ini
Dengan fitur ini, Service Provider hanya akan di load ketika memang dependency nya dibutuhkan
Setiap ada request baru, maka Serive Provider yang sudah Deffered tidak akan di load jika memang tidak dibutuhkan

Kode : Deferrable Provider
class FooBarServiceProvider extends ServiceProvider implements DeferrableProvider
{
        public function provides(): array
    {
        return [HelloService::class, Foo::class, Bar::class];
    }
}

Facades
Sebelumnya kita selalu berinteraksi dengan fitur-fitur Laravel menggunakan dependency injection
Namun kadang ada ketika kita tidak bisa mendapatkan object Application, misal kita membuat kode di class yang bukan bawaan fitur Laravel, pada kasus seperti ini, Facades sangat membantu
Facades adalah class yang menyediakan static akses ke fitur di Service Container atau Application
Laravel menyediakan banyak sekali class Facades, kita akan bahas secara bertahap
Semua class Facades ada di namespace https://laravel.com/api/9.x/Illuminate/Support/Facades.html

Kapan Menggunakan Facades?
Selalu gunakan facades jika memang dibutuhkan saja, jika bisa dilakukan menggunakan dependency injection, selalu gunakan dependency injection
Terlalu banyak menggunakan Facades akan membuat kita tidak sadar bahwa sebuah class banyak sekali memiliki dependency, jika menggunakan dependency injection, kita bisa sadar dengan banyaknya parameter yang terdapat di constructor

Facades vs Helper Function
Di Laravel, selain Facades ada juga Helper Function, bedanya pada Helper Function, tidak dikumpulkan dalam class
Contohnya sebelum kita sudah menggunakan Helper Function bernama config() atau env(), itu adalah Helper function yang terdapat di Laravel
Penggunaan helper function sebenarnya lebih mudah, namun jika dibandingkan dengan Facades, maka penggunaan Facades akan lebih mudah dimengerti secara code

Kode : Config Facades
<?php

namespace Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Foundation\Testing\WithFaker;
use Illuminate\Support\Facades\App;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\Log;
use Tests\TestCase;

class FacadeTest extends TestCase
{
    public function testConfig()
    {
        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);

        var_dump(Config::all());
    }

    public function testConfigDependency()
    {
        $config = $this->app->make('config');
        $firstName3 = $config->get('contoh.author.first');

        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);
        self::assertEquals($firstName1, $firstName3);

        var_dump($config->all());
    }

    public function testFacadeMock()
    {
        Config::shouldReceive('get')
            ->with('contoh.author.first')
            ->andReturn('Eko Keren');

        $firstName = Config::get('contoh.author.first');

        self::assertEquals('Eko Keren', $firstName);
    }
}

class FacadeTest extends TestCase
{
    public function testConfig()
    {
        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);

        var_dump(Config::all());
    }

Bagaimana Facades Bekerja?
Facades sebenarnya adalah class yang menyediakan akses ke dalam dependency yang terdapat di Service Container
Semua class Facades adalah turunan dari class Illuminate\Support\Facades\Facade
Class Facade memiliki sebuah method __callStatic() yang digunakan sebagai magic method yang akan dipanggil ketika kita memanggil static method di Facade, dan akan meneruskan secara otomatis ke dependency yang terdapat di Service Container
Contoh Config::get() sebenarnya akan melakukan pemanggilan method get() di dependency config di Service Container
Untuk nama dependency yang terdapat di Container, kita bisa lihat di method getFacadeAccessor() di class Facade nya

Kode : Config Dependency
    public function testConfigDependency()
    {
        $config = $this->app->make('config');
        $firstName3 = $config->get('contoh.author.first');

        $firstName1 = config('contoh.author.first');
        $firstName2 = Config::get('contoh.author.first');

        self::assertEquals($firstName1, $firstName2);
        self::assertEquals($firstName1, $firstName3);

        var_dump($config->all());
    }

Facades Mock
Salah satu kekurangan menggunakan static function biasanya sulit untuk di test, karena mocking static function sangat sulit
Namun untungnya, di Laravel, sudah disediakan function untuk melakukan mocking di Facades, sehingga kita bisa mudah ketika implementasi unit test
Laravel menggunakan library Mockery untuk melakukan Mocking Facades
https://github.com/mockery/mockery

Kode : Facades Mock
    public function testFacadeMock()
    {
        Config::shouldReceive('get')
            ->with('contoh.author.first')
            ->andReturn('Eko Keren');

        $firstName = Config::get('contoh.author.first');

        self::assertEquals('Eko Keren', $firstName);
    }

Daftar Facades
Ada banyak Facades di Laravel, dan seperti dijelaskan sebelumnya, hampir semuanya banyak menggunakan dependency di Service Container
Untuk lebih jelas tentang ada Facades apa saja, kita bisa lihat di sini :
https://laravel.com/docs/9.x/facades#facade-class-reference
